US	50487699	R7AAE7YMWVE6Q	1590594355	774795248	Web Services in Finance	Books	5	0	2	N	N	Practical approach to developing Web Services	Dr. Watters takes a practical approach at developing Web Services application - rather than theoretical conceptual approach to the topic.  He approached the topic from both the J2EE and .NET programmer's point of view, and provides examples throughout the text that demonstrates both A) strengths and weaknesses of each platform for developing Web services, B) broad and yet finance-industry focused application of Web services.  Examples demonstrated throughout the text are easy to follow and relate to.  One example that is referred to often in the text related to checking balance of a band account and a more complicated stock trading application which the author used to demonstrate WDSL and UDDI examples.   <br /> <br />I had read a number of books on SOA and Web services in general, but I found the \\"how-to\\" approach of this book very helpful.  Not that the author does not cover the basics of Web services, but he does so with demonstrating the concepts thru code samples and workable programs throughout the chapters.  Background information on how and why Web services fit into the finance industry start the book - followed by an introduction to why the current systems such as CORBA and various MOM's are not doing the job right now.  He follows up with the basics of data representation: XML, DTD and XML Schema.  These topics are covered very briefly, and can be skipped over.    <br /> <br />Messaging with SOAP is an essential part of Web services.  All other protocols and layers rest atop of SOAP - and messaging.  Two subtopics are worth highlighting: SOAP binding with HTTP and the available software packages in .NET and Java.  Later in the text, the author discusses other SOAP binding protocols such as SMTP, POP, JavaMail and IMAP.  WSDL is needed to define the endpoints that represent services.  Examples from the SOAP chapter are expanded to take into account WSDL and UDDI, in the chapter that follows.   <br /> <br />Security is an important topic and much more so inthe finance industry.  Authentication, Authorization, Secrecy and trust are some of the requirements that Web services security protocols need to fulfill.  The problem with security standard is that there are too many of them: 7 protocols that cover the security aspects of Web services to be exact.  The author covers these topics as they pertain to the finance industry and follows each discussion with the appropriate example.   <br /> <br />In about 200 or so pages, Paul covers the topic of Web services quite well.  His examples are applicable to the finance industry and are very easy to follow.  Even if you have read other books on Wed services, I highly recommend this book to you as it will make a very good edition to your book collection.   <br /> <br />	2005-08-01
US	50487699	R2AXC72YWUU8EO	1593270364	623146649	Linux Enterprise Cluster: Build a Highly Available Cluster with Commodity Hardware and Free Software	Books	5	24	26	N	N	One stop guide to building a Linux Cluster	The sheer number of books published in the recent years that cover the Linux Operation System is simply staggering.  One aspect of Linux that has been explored recently is its enablement that is gives users that wish to build a clustered environment.  Using free software and commodity hardware many organizations small to large, and even end-users such as myself, have been able to build a cluster or a Grid using Linux very cheaply.  This book by Karl Koppers shows the readers a step-by-step guide of how to go about building an enterprise grade Linux cluster environment.  The author depicts each step one by one for the reader and demonstrates what each step does and why \\"we do what do we\\".   <br /> <br />The following steps required for building a cluster are explored in detail in this book: <br />* Understanding of the underlying Linux routing (NetFilter and basic packet routing) <br />* Understanding of SystemImager program, and how it can help you in building a large cluster <br />* Learning of to apply configuration changes to your cluster efficiently <br />* Learn to build a Linux Virtual Server Network Address Translation fro your cluster, and learn why you need such capability <br />* Learn how to manage failures in your cluster including software and hardware failures <br />* Learn how to manage and monitor your cluster from a single point using a Web-based GUI <br />* Learn how to apply software patches and updates to your cluster  <br />* Administrator user accounts and remote login including password-less login via SSH <br />* Learn how to install a cluster print server <br />* Learn how to install a batch-job scheduling system on your cluster <br /> <br />As you can see, there are lots covered in this book.  Some of the basics of the underlying Linux system and Kernel gets the reader off on a good start, and starts the foundation upon which the rest of your cluster can be built.   <br /> <br />Unlike any other book that claims to cover this topic, Karl hasadded a number of chapters on the understanding (he calls them theory of ...) of the concept and why things are done the way they are instead of just telling the reader what to do.  These chapters can be skipped, obviously, but I found them to be extremely useful because it gives me a deeper knowledge of the topic at hand makes me understand the topic better.  The whole point of the book is to enable someone, by simply going thru the book chapter by chapter, to build a medium to a large size cluster.  A how-to guide that is packed with the appropriate software packages discussed in the text.   <br />My favorite topics in this book must the central administration of the cluster via Ganglia, and High-Availability configuration chapters.  These two, monitoring and reliability, are key difficult areas which the author covers in detail.   <br /> <br />The combination of the book and the accompanying CD-ROM packed with software packages make this book a great buy.  I have built my own cluster, but I am re-doing my environment by going thru this book chapter-by-chapter.  I highly recommend this book to anyone involved or interested in building or maintaining Linux Clusters.   <br /> <br /> <br />	2005-07-18
US	50487699	R3SVVXLQMPFELP	0387240489	423894817	High Performance Computational Science and Engineering: IFIP TC5 Workshop on High Performance Computational Science and Engineering (HPCSE), World ... in Information and Communication Technology)	Books	5	1	1	N	N	covers three essential topics in HPC	This text contains selected papers from the International Symposium on High Performance Computational Science and Engineering that was help in France on August 27, 2004.  This conference is focused on new research in algorithm, computational complexity and essentially problem solving using high-performance systems.  Three topics in high-performance computation are covered in this text: distributed computing, numerical computation and computational applications.   <br /> <br />The key note that needs to be mentioned is the fact that the papers covered in this text are engineering focused, and thus very applicable.  In fact, the last section of this text, computational applications, are case studies from different researchers, each focusing on a specific application: image analysis for biological systems, satellite system optimization problem, optimization technique for Airline reservation and text classification in the World Wide Web using Neural Network.  These papers represent real-world problems and applications of where the problems are very complex, and ingenuity is required to come up with an efficient algorithm to solve the problem at hand.  The fact that problems are taken from the real world gives the reader a good sense of the overall picture of the text.  I read this section on algorithms first, and then I went back to the other chapters of the text; this way I had a better appreciation of what the rest of the authors were talking about.   <br /> <br />Distributed computing has been around for sometime now, but there are still complex problems surrounding distributed memory management that hunt the researchers.  The first section of this text covers the main problems in distributed computing, and especially problems surrounding distributed shared memory.  Another complex problem with distributed systems is the uncertainty of the overall static and dynamic performance of the system.  Two papers cover this very complex topic, and given an insight of the available tools and techniques used for simulation and modeling of distributed systems.   <br /> <br />Algorithms and related topics are covered in a section titled Numerical Computations.  Three papers are selected that focus on optimization of currently in place algorithms such as the Poisson equation, extraction of zeros in large analytic functions and optimizing the sparse Cholesky factorization.   <br /> <br />All and all, this text covers two important topics in high-performance computation.  The section on applications reels in the topic at hand.  The editors did a great job selecting the right papers to be published in this text.   <br /> <br /> <br />	2005-07-18
US	50487699	R23DBBKCJJJBP0	1584503718	726287254	GNU/Linux Application Programming (Programming Series)	Books	5	41	44	N	N	Gets you up and running with Linux programming	All the topics that one needs to read to come up to speed with Linux programming, development and maintenance, scripting and even tuning are covered in this book.  The author starts with the basic architecture of the Linux operating system, and delves into the details of each part: scheduler, memory manager, virtual file system, network, ipc and init.  The reader starts with an overview of what the Linux operating system looks like \\"under the hood\\", and is taken thru a series of sections that cover application development using each section of the Linux kernel.  Overview application programming, performance analysis and debugging using various GNU tools such as the the GCC complier, make, gcov and gprof are given first and are used throughout the book by the author to further demonstrate the features and benefits of the available GNU tools.   <br /> <br />By now, the reader is presented with the necessary tools needed to create application, and is not time to delve into specific programming techniques and API's.  The book starts with simple file handling API's and examples, and goes into more complicated topics such as: <br />* Linux Pipes <br />* Sockets programming <br />* Multi-process development and the Linux process model <br />* Multi-threaded development and the Linux threading model <br />* Messages Queues <br />* Synchronization and Semaphores <br />* Shared memory programming <br />Even though each of these topics are very complicated and an entire text could easily dedicated to it, the author with elegance covers each topic such that the reader could get an overview of what is at stake.  Each topic is rather short, and very well written with examples and a step-by-step instruction of how to write simple programs.  Each chapter is like a short and sweet introduction to the topic at hand.  One of my favorite chapters is, \\"Synchronization with Semaphores,\\" in which the author further illustrates the point using sequence diagrams of events, elaborated examples and tips on how-to's.   <br /> <br />The chances are that programming in a high-level language such as C is not enough, and one needs to compliment his/her application[s] with scripts and many other available Linux tools and commands.  The last section of the book is dedicated to what some people might call odd-and-ends, but to me, they are as important as any other topics in this book.  Bash, Sed, awk, flex and bison are some of the scripting languages that are covered.  As with the previous sections of the text the author covers each topic using examples plus a step-by-step depiction of each example. <br /> <br />If you are new to the Linux programming environment or you need a refresher text like I did, you will find this book very useful.  Tim does a fantastic job covering a broad topic, and doing so with such ease and elegance.  The examples are priceless, and the CD at the end of the book has complete source code to the examples given in the book.   <br /> <br /> <br /> <br /> <br />	2005-07-18
US	50487699	R1PE94YPSLPCQS	0321334876	873352202	Effective C++: 55 Specific Ways to Improve Your Programs and Designs (3rd Edition)	Books	5	67	69	N	N	Third Edition: Improving an already great book	How do you improve a book that has been known as a \\"bible\\" in the C++ community for years?  As Scott mentions at the beginning of the text, he almost threw everything out, and started from scratch.  When I first say the book, I thought that there are five new items that were added to the book, but I couldn't be more wrong.  As you might have guessed, C++ has gone thru a number of significant changes over the past decade, and the third edition of this book is updated to take advantage of the new editions to the C++ standard.  In reality, almost every item in this book has gone thru a re-write.  Many have been consolidated and new chapters, topics and many new items have been added.  A few items that did not make sense anymore like items 2, 3 and 4 in the second edition are removed from this third edition.   <br /> <br />Scott breaks down the c++ language into 4 subparts:  <br />* The old C subsystem.  Before all these advanced programming languages such as Java and .NET came, C was the language of choice.   C++ is \\"translated\\" to C first, and then complied and linked to an executable.   <br />* OO C++, which is C with Classes.  This is where the concept of Object Orientation in C++ started.  Even though this concept was very much new a decade ago, it is very much part of a programmer's vocabulary. <br />* Template C++, which is the newest edition to the C++ standard and it brings with it the concept of Template Metaprogramming.  This concept is very much new, and this book has dedicated a whole chapter around templates, and template metaprogramming.   <br />* STL, which is the C++ Standard Template Library.  Again, STL was a new concept a few years back, but it is very much an established notion in C++.   <br /> <br />Scott has taken a new approach to this book and has covered all four of these subparts.  He has a book dedicated to STL, but he is using STL notions and \\"language\\" throughout this book.  The chances are that the reader is already familiar with other languages such as Java and .Net, so the text covers area where these two languages differ with C++, especially in the area of inheritance and polymorphism.  But not everything has changed.  Topics such as,\\"Explicitly disallow the use of Compiler Generated functions you do not want,\\" will never get old or outdated.   <br /> <br />New chapters cover topics such as C++ Template and Generic Programming, Resource Allocation and topics that cover the latest C++ standard and additions, including the TR1 (Technical Report 1).  \\"new and delete\\" have been separated into their own chapter, and the author goes into great depth demonstrating to the reader the various ways that these two operators can be modified, and why.   <br /> <br />Exceptions and programming in light of exceptions is also a very new concept in C++.  The previous versions on this text did not touch on exceptions all that much, but the author has spread the use of exceptions throughout the text, with a number of items dedicated explicitly to exceptions and exceptions handling.   <br /> <br />The updated items, new topics and chapters and a new look and feel of the text with color coded examples make this book a joy to for C++ programmer to read. <br /> <br /> <br /> <br />	2005-05-27
US	50487699	R4SG79A9OTF7M	1402072090	134912863	Distributed and Parallel Systems: Cluster and Grid Computing (The Springer International Series in Engineering and Computer Science)	Books	5	2	3	N	N	Covers the essential topics in Grid and Parallel Computing	Unlike conference proceeding, this book is a collection of papers that were presented at a Workshop, which are usually shorter in length and more focused on a specific area.  This Workshop, 4th Austrian-Hungarian Workshop on Distributed and Parallel Systems, covered four specific, and yet very important aspects of Distributed and Parallel Computing: <br />1) Tools and techniques in Cluster Computing, which covered Load Balancing techniques, tools used for simulation and performance prediction, management tools used for abstraction of the underlying infrastructure <br />2) Global Grid Computing, which covered topics that concern large Grid management and Load Balancing in global Grids, dynamic resource discovery techniques and virtualization of resources to represent the user with a Single System Image (SSI) <br />3) Parallel Software Development techniques and tools, which covered the latest trends and available tools for developing applications for the gird, architectural techniques for caching, debugging techniques to shorten development time, and testing and deployment ideas for large grids. <br />4) Dependable and Fault-Tolerant Systems, which covered topics such as fault-tolerant techniques for storage systems, getting around the unpredictability of creating a fault tolerance distributed and parallel system, and failure detection and recovery techniques <br /> <br />As mentioned, the book/workshop does not try to cover everything under the sun, but what it does cover; it does so with applicable, useful and relevant papers.  The researchers are basically presenting their own experiences and best-practices to the readers.   <br /> <br />Even though the topics presented are academic for the most part, there are a number of ideas, techniques and tools that the reader can take away.  One such tool is P-GRADE.  There are three papers covering this tool in this book: two on load-balancing and one in software development and engineering.  P-GRADE is a graphical tool that provides programming environment for developing parallel applications using graphical representation for communication, etc...  It also has a number of tools for debugging, monitoring and visualization.  The tool takes the graphical representation of your application, and develops C code for it, which could be compiled for any system.  It is an open-source, free software and it is getting plenty of attention in Europe. The tool makes the complex task of developing software for a Grid Environment simpler, and even though it does not literally write the code for you, it will assist you where it can such as easing the pain of network programming and communication.   <br /> <br />I highly recommend this book for architects, researches, professionals interested in papers that are not entirely research-based and there are applicable techniques that can be learned from them.   <br />	2005-05-18
US	50487699	R3938VW0V20TIQ	0130479756	413756737	Sun&#8482; Cluster 3 Programming: Integrating Applications into the SunPlex&#8482; Environment	Books	5	1	1	N	N	A must read for a Sun Cluster user	There are a number of ways to learn your way around the Sun Microsystems's Cluster 3 (SC3) software such as spending thousands of dollars on the training course, or you can simply read Sun Cluster 3 Programming by Joseph Bianco, et. al. and save yourself lots of money.  This book has been written and reviewed by some of Sun's best architects and engineers, so the information presented is not only actuate but also very applicable to how end-users are using the product.  Even if you have taken the training course and have been using the software for sometime, this book is still a valuable reference to be added to your bookshelf.   <br /> <br />In short, \\"Sun Cluster is a powerful software environment capable of providing high levels of application availability to almost any application.\\"  There are a number of applications such as Oracle, Sybase, DB2, SAP and many others that can directly take advantage of the SC3 environment, but the book also demonstrates how one can write applications using the provided API to achieve the same goal.  Being one of the pioneers in the high-performance computing realm, one can learn much from the ins and outs of the SC3 environment.  I personally think that SC3's Resource Group Manager (RGM) is simply the state of the art.  RGM, which is covered in detail in this book, is the monitoring module that all the other software applications that run on the cluster interact with using an event-driven callback model.  RGM is configured to check the state of the cluster, and in case of an event, use one of the registered callbacks to take actions.  The callback methods hover around the application and take actions when necessary.  This allows for an automated response in case of a failure, and makes the task of cluster management a lot simpler.  In addition to giving an overview of what makes up the Sun Cluster software, the authors go thru the entire set of Resource Management API (RMAPI).  RMAPI is used to interface with the RGM, and is integrated into your application to make your application \\"cluster aware\\".   <br /> <br />The authors introduce two types of applications: cluster aware applications and cluster compatible applications.  The chances are that your application is cluster compatible, and with the RGM, you can still manage your applications at a high level (start, stop, check process status, etc).  With the RMAPI, you can make your applications be cluster aware, which means that you can more tightly integrate and thus control the internals of your applications with the RGM.  The authors spend the part of the book on how to make your application cluster aware.  The SC3 API's are written in the C programming language, but various scripting languages can also be used.  The API's can also be wrapped in C++, and the object oriented way which the SC3 is architected makes the task of wrapping the API's very simple.   <br /> <br />The authors bring the book to a closure with a full blown example of two applications that: one that is cluster compatible and one that we want to make use of the available API's and make cluster aware.  The authors go thru the example step-by-step, and explain each step thoroughly.  The readers learn the process, and use this example for future development.   <br /> <br />I recommend this book to anyone using or interested in the Sun Cluster 3 application.  The authors are experienced Sun architects and engineers, and provide the readers with valuable information about the internals of the Sun Cluster 3 environment.  <br />	2005-05-02
US	50487699	RV6B81CFFLJ4Z	1893115275	869498225	Tuning and Customizing a Linux System	Books	5	2	2	N	N	A must read for professional moving to the Linux OS	The growth and the penetration of the Linux Operating System in the recent years has caused an increase in both the need for professionals familiar with Linux and an increase in the sheer number of available books, journals, web sites, etc, that cover this topic.  Morrill's book on Tuning and Customizing a Linux Operating System finds its way to the top of the \\"must read\\" stack due to its applicable coverage of the topic.  The author starts with the Linux mentality and \\"physiology\\" and delves into the details of how to build, maintain and administrator a Linux-bases workstation or PC.  Other book cover the commands, or at a more engineering level, cover programming in the Linux environment, but this book talks about how to actually build a Linux-based system and how to configure it.  Talks about how the file system in configured, and why the directory structure is the way it is.  It talks about how to install, remove or update software packages to your system under three popular Linux OS distributions.   <br /> <br />To me, the most valuable part of this book was the explanation of why \\"things\\" are the way they are.  For example, why there are /etc, /usr/etc/ and /usr/local/etc in the directory structure of Linux?  And why you should pick or refer to one over the other if you need to look for a configuration file?  To me, these are the details in one handy chapter that is very hard to find, and one would only get that type of information from an expert who has been working in the field for a number of years.  The example I just gave is along the same lines of the other examples and topics that you find in this book.  Three different Linux distributions are covered: Red Hat, Slackware and Debian.  Each distribution is covered in detail, and their differences are pointed out.  The authors show the reader how to do basic administration and tuning for any of these packages.  The package installation utilities such the RPM from Red Hat, the Slackware's classic tarballs,and the dpkg program from the Debian distribution are discussed and compared.  The options pertaining to package customization are covered in detail, and examples are given for each tool.   <br /> <br />You need to keep in mind that this book teaches you how to install and configure your Linux system, and how to navigate your way around it.  This book does not cover each command nor does it cover the programming aspects of Linux.  It discusses the installation and manipulation of the operation system and any software package that you may want to install and configure on your system.  Six popular programs are given as an example of the various ways that almost any software package is installed on Linux.  These packages include: <br />* The OpenSSH Secure Shell <br />* The Pluggable Authentication Modules <br />* SOCKS Library <br />* Apache HTTP Server <br />* CVS <br />* Java JDK <br /> <br />In addition to being a very useful reference, these examples portray how manage any software installation in Linux.  The three different Linux distributions are referred to throughout the text, and the variations between how each system is manipulated and customized to take advantage of the newly installed software is given.   <br /> <br />The author brings the book to a closure with detailing two case studies: how to build a simple desktop system, and how to setup a corporate software development environment.  All the topics covered in the text are revisited with these two case studies to bring the topic to a full closure.   <br />	2005-05-02
US	50487699	R36K6B18GBXM6I	1584502509	469072243	Algorithms & Data Structures: The Science Of Computing (Electrical and Computer Engineering Series)	Books	5	8	8	N	N	A good mix of programming and algorithms design	Algorithm and Algorithm design is a difficult topic to talk about or to learn.  It is probably one of the most complex topics in the field of Computer Science and Mathematics, mostly due to its abstractness.  Proof after proof, theory after theory, and complex mathematical expressions make the topic very difficult to grasp at times.  The authors of Algorithms and Data Structures have taken this notion into account, and wrote this book in such a way that a Computer Science major student can relate popular programming and problems that we come across everyday to the notion of algorithm and complexity.  The Java programming language is utilizes throughout the book, and the authors, D. Bladwin and G. W. Scragg, write pseudo-Java-code to demonstrate how, for example, various versions of the quicksort algorithm are coded.  Programming is obviously not the focus of this book, but the code snippets are certainly a good teaching aid for the novice readers.<br /><br />The book starts off with the basic ground work surrounding algorithms: what is a proof? Computer Science, Mathematics and theory, etc..  It basically answers the question why anyone should bother learning about algorithms and the complexity that surrounds this topic.  The authors then take a rather unique approach to the theory behind algorithms by discussing program recursion and iteration.  It seems a little odd, but it turns out to be a very good way to introduce readers to topic algorithms.  Recursions is a topic covered in CS1 courses, and using that as the basis and introduction to algorithm design and correctness proof really reels in the reader and makes the topic easier to grasp.<br /><br />After discussing algorithms basics, and showing the readers what algorithm efficiency, etc is, the authors take on the second part of the book which covers the data structures aspects of things.  List, Queues, Stacks, Trees, etc... are all covered in detail.  Algorithms that were discussed earlier in the text are applied to the data structures, and the complexity of each algorithm is actually depicted thru examples, pseudocode, and followed by its mathematical analysis.  The text, in general, is focused around the concept of objects, abstract data types, and core object orientation techniques, and the presented material is targeted as such.<br /><br />Towards the end of the text, the authors give the readers a brief but concise overview what's to come.  Topics such as complexity, the undecideability, nondeterminism and the surrounding problems such as the HALTing problem, the Traveling Salesman Problem, etc... are touched.  The authors pose some very interesting questions for the readers in the context of the HALTing problem as it pertains to complier design.  These problems in their general form are unsolvable, and the authors make a very good case on why we care about such problems and issues.<br /><br />In addition to being a very easy text read, the authors have filled each chapter with sample problems, examples, and techniques.  For the second year computer science student, or a professional interested in the field of algorithm design and complexity analysis, I highly recommend reading this text.are applied to the data structures, and the complexity of each algorithm is actually depicted thru examples, pseudocode, and followed by its mathematical analysis.  The text, in general, is focused around the concept of objects, abstract data types, and core object orientation techniques, and the presented material is targeted as such.   <br /> <br />Towards the end of the text, the authors give the readers a brief but concise overview what's to come.  Topics such as complexity, the undecideability, nondeterminism and the surrounding problems such as the HALTing problem, the Traveling Salesman Problem, etc... are touched.  The authors pose some very interesting questions for the readers in the context of the HALTing problem as it pertains to complier design.  These problems in their general form are unsolvable, and the authors make a very good case on why we care about such problems and issues.   <br /> <br />In addition to being a very easy text read, the authors have filled each chapter with sample problems, examples, and techniques.  For the second year computer science student, or a professional interested in the field of algorithm design and complexity analysis, I highly recommend reading this text.   <br /> <br />	2005-03-25
US	50487699	RHO7EPHEBNFEB	0130652482	854972614	Numerical Methods Using Matlab (4th Edition)	Books	5	16	18	N	N	Much needed book	Whether you are an instructor for an Engineering class, Life Sciences, Statistics, Mathematics, or simply want to add practical mathematical analysis and programming, this book is the book you should use.  I have been using Matlab for a number of years, and I had to pick up my Matlab knowledge from the manuals, man pages, the Internet, etc... and finding out the ins and outs of how to do something was not always an easy task nor accurate.  Mathews and Fink's book put all you need to know about the most popular Mathematical methods at your finger tips.  The book is tailored such that it can be used alone in a Mathematics course, or as reference in an Engineering course.  One field of study that has enjoyed the power and flexibility of Matlab in the recent years is Computational Biology or Bioinformatics.  Even though there are plenty of applications popping up here and there for this area of research, the area is still very much untapped and algorithms need to be developed for it as we go forward.  Matlab is the best way to try out these new or improved algorithms, and use some of the available tools out there to generate C source code from your Matlab files.  This method of algorithms development could save you tons of time, since Matlab makes numerical programming very simple.   <br /> <br />The authors start with the basics in Numerical Methods; assuming that this book will be used as the primary text book in the course.  A very good assumption, and the instructors who choose otherwise, can always skip the preliminaries.  The context of text aims to provide a good balance of theory and application.  One way that the authors try to keep this balance is to talk about \\"error\\" rate for the algorithms in question.  The students are thought the limitations of Matlab along with the strengths of the software, and error analysis is one way to show the students that the results of numerical analysis is Matlab is not perfect, and more importantly why.  This error analysis isdone for every major algorithm and method presented in the text, and a number of methodologies are presented to help the student in figuring out this rate.   <br /> <br />Authors start the main contents of the book with a representation of basic Linear Systems followed by a more complicated topic of Polynomial Approximation.  Taylor Series and Lagrange Approximations are thoroughly covered in theory followed by examples that are solved by \\"hand\\" and by Matlab.  The examples are complete, and can even be used, at least to start with, for the problem sets at the end of the chapter.  As one would guess, curve fitting is the next topic of discussion.  As you know, numerical techniques in science and engineering often requires curve fitting of experimental data.  Starting with simple techniques of Least-Squares Lines, non-Linear Least-Square Methods and ending with the four different flavors of Spline Functions.  The Matlab examples becomes more advanced as the topic progresses, and more and more examples are given as the topics get more complicated as well.   <br /> <br />One can not learn Numerical Methods without a deep understanding of Numerical Differentiation and Numerical Integrations.  Numerical methods for Differentiation are used to solve boundary value problems in ordinary differential equations and partial differential equations.  Heat Transfer, Semiconductor Physics and Device Modeling, an Physical modeling of Molecules are just some of the examples that use these numerical differentiation techniques to solve problems.  As is the case with the book, the authors start talking the theory behind how numerical differentiation works, and then, they go into the Matlab representation of the problem.  Various approximation methods are presented, and error rate for each approximation method is also calculated in detail - both by hand and using Matlab.   <br />Numerical Integration is a bit more difficult, as there are a number of ways to calculate the area under a curve.  The authors present four numerical methods in detail: quadrature, composite trapezoidal, adaptive quadrature and Gauss-Legendre Integration.  Each theory is followed by an example Matlab programs.  The authors wrap up the text by talking about differential equations and partials differential equations.  These two topics are difficult without using numerical methods, and it is even harder to follow the numerical theory of these topics.  The authors take a slightly different approach to these topics.  They start with examples from the get go.  Instead of laying down the theory, they start each chapter with relevant examples from simple to more complex and abstract.  Wave Equations and Heat Transfer equations are well known applications of PDE that are presented in detail.   Eigenvalues, eigenvectors and the Jacodi's Meothod wrap up this text by j. H. Mathews and K. D. Fink.   <br /> <br />I would recommend this book to be used for second year Mathematics, Physical Sciences or Engineering students.  A course in Numerical Methods would benefit greatly from this book.  Other students can certainly use this text to assist them with modeling, simulation and statistical problems in Electrical Engineering, Mechanical Engineering and various Applied Chemistry and Physics courses.   <br />	2005-03-25
US	50487699	RL96E6IQ4CRTQ	1893115585	59941958	Architecting Web Services	Books	5	1	1	N	N	A timeless read	There are a number of books written on Web services, but what makes this book different is that the author focuses on the concepts and patterns behind architecting Web services rather than current protocols.  The author outlines the steps and the process that an architects needs to take to architect a solution around Web services, and why that solution is different than, for example, pure client/service type architecture.  The software engineering aspects of architecting a solution with Web services in mind is depicted in detail, and that approach makes book rather timeless.   <br /> <br />If you have been architecting software applications using one of many popular methodologies (pipes and filters, client/server, n-tier or layering, feedback and feedforward systems), you need to bridge the gap between what tends to be rather coupled solution to a Web services architecture, in which the components are very loosely coupled or not coupled at all.  This might seem like an easier approach for an architect, but the difficulty rises when you try to architect systems that are for the most part self-contained.  Component-based software design (CBD) has never been an easy task, and Web services architecture is an extension of CBD.  The author extends the available literature from CBD, and provides a guideline for the readers on how to go about architecting Web services. <br /> <br />Three components that compose a Web services model are detailed throughout the book: presentation, interface, and security.  Presentation, as you can imagine, mostly focuses on the user experience.  The author makes a very compelling argument on why a good Web services presentation adds value for the users and the service providers as well.  What the user experiences while using the service will become the key differentiator in choosing the right service.  Interface model is what the user sees.  The service user interacts with a service (programmatically) thru its interface, and as a service provider you need to think about what that interface should be.  You might use a faade design pattern and expose a limited number of service invocation methods, but behind the seen, take care of much needed interaction between various of services from various locations.  The security model, as you can imagine, is concerned with the security aspects of the services.  The author talks about security as a separate entity thru which your design is manifested; as approach that is widely practices today.  A hybrid of all the three models discussed is usually used, and a comprehensive example walks the readers thru how this is accomplished.  The goal is to give the reader the ability to chunk-up your problem into chewable pieces, and solve one small problem at a time. <br /> <br /> <br />Another area which Web services are making strives at is workflow.  The author dedicates a good portion of the book to this topic, and shows the reader how this task is done.  The idea is to be able to assemble loosely coupled services into a full-blown workflow engine at run-time without loosing predictability and reliability in the process. Workflow is all about predictability of how your processes in the enterprise should behave.  Due to their nature, Web services have a certain flare for being unpredictable.  One can imagine the difficulty that rises in trying to integrate what by nature seems to be un-doable.  The author represents the topic very elegantly, and discusses the pro's and the con's on using Web services for workflow.   <br /> <br />In closing, this book is a must read for any architect working with Web services.  The topics are not protocol dependant, so you don't have to worry about learning stale data.   <br /> <br /> <br />	2005-03-07
US	50487699	R2Z95CNQ5C8LW4	0201721481	411641420	C++ Primer (4th Edition)	Books	5	4	4	N	N	Learn to become an efficient C++ programmer from the start	The traditional way to teach programming, especially C++, has been to introduce the basics of the language and building on top the basics as the book progresses.  Lippman, et. al. have diverted from the traditional way of teaching C++, which leaved the reader with a better understanding of the topic and the language as whole.  Instead of creating yet another \\"C++ Reference Manual\\", which in turn gives the reader a very detail description of the language, the authors have focused on the effective and current best practices in C++ from the get go.  The Standard Template Library is introduced early on in the book, and the readers begin to experience \\"how things are done in the real world\\" early on, instead of waiting until the end of the text.<br /><br />C++ is a powerful language; more importantly, it is language that gives its users plenty of power.  Enough power and freedom that if not tamed, could become very dangerous.  Unlike some other \\"newer\\" programming languages, C++ has the ability to manipulate the lowest levels of the system: hardware and the operating system.  The authors took this notion into consideration and wrote the book in such a way that proper programming techniques and methodologies are \\"forced\\" from the beginning.  Programming in C++ also requires a different mind-set as well: objects, classes, inheritance, polymorphism, etc...  These are topics best understood by example.  The standard template library (STL) is the best way to show the users how the most powerful techniques in C++ are being utilized.  Starting with the String and the Vector classes, the authors walk a very fine line of teaching the novice users about the ins and outs of the language and others how to best take advantage of the available libraries that are provided with the language.<br /><br />To new readers of the language this approach might seem a bit difficult to grasp, but the fact of the matter is that C++ is not an easy programming language to learn.  If you are seriousabout learning C++, what better to learn the language than learning the right way from the start?  It might seem a bit overwhelmed at first, but that's ok.  There is a glossary of introduced terms at the end of each chapter, along with a summary of topics covered.  At the beginning of each section (part) of the book, the authors give an overall summary what's to come, and why these topics are covered when they are.  The same goes for the beginning of each chapter: a summary of what's to come begins each chapter before the material is covered in detail.  The authors realize that the approach might seem a bit unorthodox, and take extra care in making sure the readers are not overwhelmed with information.  For people with C++ experience, you will appreciate this method of teaching a lot more.  The readers are exposed to \\"important\\" C++ terms and phrases from the beginning instead of waiting until the last couple of chapters of the book.<br /><br />Other than the format change, and updated material to comply with the latest ANSI C++ standard, this book has updated examples the source code for which can be downloaded from the book's web site.  There is C programming coverage in this book, which is very good.  The programming style is C and C++ are inherently different (procedural and object-orientation), and talking about C would simply confuse the readers.  The book's focus from the beginning to the end is how to best utilize and write programs in the C++ programming language: how to become an efficient C++ programmer.<br /><br />I recommend this book to anyone interested in learning the C++ programming language.  If you have used C++ before, this book is still a valuable addition to your library, as it covers C++ with efficiency and proper programming style in mind.	2005-02-27
US	50487699	R39PPS1QZ73OKE	0321246241	233206787	UML for Mere Mortals	Books	5	7	8	N	N	Short, easy to read and to the point	The sheer number of books on UML is simply amazing, and it seems like finding a right one for you is a task all into itself.  No matter whom you want to become, a hardcore UML modeler or a weekend reader feeding one's curiosity, the book \\"UML for Mere Mortals\\" is a great way to start.  The main and important topics are covered, and the details are left untold.  That's perfectly ok, since even the UML professionals don't refer to all aspects of UML due to its complexity.  Simple UML diagrams are easy to grasp, but UML for large projects get very complicated, making the users of UML stick to common diagrams in order to get the point across more easily to readers.  What is the point of a complex and intertwined diagram if you are the only one that can read it?   <br /> <br />It is crucial to keep in mind that the goal is to model your enterprise in order to have a common language across all aspects of business via which everyone can communicate.  What is the point of accomplishing this task if no one else in your enterprise can understand what you are trying to say?  You have accomplished nothing, and only wasted away hours of work.  The authors of the book have this mentality in mind when they are talking about UML.  They start with basic stuff such as Business Modeling and Business Use Cases: a top-down approach if you will.  The fact of the matter is that UML can readily model all aspects of an enterprise from what is called Business Use Cases all the way down to how each executable piece of software is deployed. <br /> <br />After Business Modeling has been accomplished, it is onto requirements modeling with Use Cases.  A Use Case driven process, where your capture your requirement solely using Use Cases has shown to be the best way to start a new project.  The concept of \\"separation of concerns\\" fits perfectly into this methodology, and there are a number of books that talk in detail about it.  After capturing your requirements, it is now time to get working on the Architectural designs using Class Diagrams, and think a bit about deployment and component diagrams.  A more difficult task is to model your application, and not only pieces of it.  After wrapping up with Class Diagrams, the authors show you how to go about modeling your entire application.  It is a difficult task, but the authors break it down to easy to chew off pieces for the reader.   <br /> <br />Database Modeling and Testing are probably my two favorite chapters in this book.  These are topics that one would normally not think about when thinking about UML, but the authors show that it is not the case.  In fact, modeling your database with UML will enable all your team members to have a common language (that phrase again!), and maybe even reuse components from each others design.  The same goes with testing.  Authors suggest that the QA team should take the Use Case and Architectural Models and start working on test cases while the development is taking place.  This is a great idea as you catch bugs early in the process and the cost of fixing them is very small comparatively.   <br /> <br />UML for Mere Mortals is an easy and quick read.  If you want a book to refresh your UML skills over the weekend, or you are new to UML and need to know the essentials fast, this is the book to read.   <br />	2004-12-28
US	50487699	RCXY4YDF0T24T	0805347224	263695457	Discovering Genomics, Proteomics, and Bioinformatics	Books	5	36	38	N	N	Simply fascinating	The sheer number of books in the area of bioinformatics is growing rapidly, and each author takes a different approach to the topic: Bergeron's Bioinformatics Computing uses concepts from Information Theory, while Pervzner's Computational Molecular Biology uses Graph Theory and Durbin et. al. Biological Sequence Analysis use Statistics and hard core mathematical analysis to get the point across.  Campbell and Heyer, the authors of Discovering Genomics, Proteomics, & Bioinformatics use concepts from Electrical Engineering and Control Engineering to prescribe some of the details of genomics and proteomics.  As an instructor you need to choose the right book to meet the needs and understanding level of your target audience.  For biology students that have little mathematics or statistics knowledge but have taken Physics II (E&M), this would be the perfect book.  The authors are a little heaving on the biological terminologies, so a sophomore level Computer Science major with little or no biology background would have a difficult time coming up to speed at the beginning, but the glossary of terms at the end of the book is comprehensive enough that can aid the learning process.   <br /> <br />The approach to figuring out what, where and how genes are controlled using what are called circuits is simply fascinating.  Genes are controlled in three ways: location of the gene, the time of control and the amount.  These three metrics can easily be mapped to circuit diagram in Electrical Engineering using the concept of switches (transistors) and time varying influencers (control theory and feedback loops), the authors describe of genes are regulated.  One can imagine that the process of mapping genes into circuits is a difficult task, and one would be right.  In fact, only one gene, the Endo16, has been fully expressed in circuit diagrams and that task took years of research.  Imagine the amount of man power and hours it would take to draw the circuit diagram for the entire human genome of over 35000 genes!  Even the concepts of noise in the circuit and complex integrated circuits are explored in details.  The authors make no hesitation in telling the readers what the unknowns are and what topics are under intense investigation.  It is amazing to realize that we still a long way to go, and what we are seeing thus far is just the beginning on a very long journey.   <br /> <br />In general, the book is very interactive filled with Discovery Questions, Math Minutes and a CD simply filled with tons and tons of pictures that are in PDF format that can be printed in need be.  There is also a Web site that accompanies this book that explains various bioinformatics methods, and contains information required by some of the Discovery Questions.  The text itself is divided into four units: <br />1) Genomic Sequences which talks about the whole picture of genomic analysis and its benefits.  The question of why this field of study is so important and what we hope to gain from in the coming years and decades is also answered.  The students are exposed to topics in the areas of biological weapons, antibiotics and how they work, the evolution and survival of DNA and ethical consequences of genetics and genetic engineering. <br />2) Genomic Expressions in which the how and where questions are answered in detail.  How did we gather all of this information?  DNA microarrays are discussed in detail including advanced research in the area and who is doing in.  Proteins microarrays are also discussed, but not in as much details due to the fact that protein microarrays are very much in their infancies.  The authors do make a number of predictions in terms of where the proteomics area of research is heading and what we need to get there.   <br />3) Whole Genome Perspective.  The bottom up approach takes the readers to the whole genome analysis, and that's where the authors discuss the notions of electronic circuits in describing the genome and proteins prescription.   <br />4) Medical Case studies in the areas of drug discovery bring this book to an end.  The authors tackle questions such as how a disease is discovered and researched, and go into some of the misconceptions of drug discovery and end the book with why discovering a new drug is such a difficult task.   <br /> <br />A complete text with the entire information one would need to come up to speed with the area of life sciences.  A good mix of biology, mathematics, statistics, engineering and computer science give the reader a comprehensive overview of the current problems, research areas and new developments in the field of bioinformatics.   <br /> <br />I recommend this text for a bioinformatics course with students of biology with little mathematics and statistics background.  The text is easy to read and follow.  The accompanying CD-Rom is field with relevant pictures, graphs, etc, that can further the learning process.   <br />	2004-12-07
US	50487699	R2L0PUONZWT74C	0131008250	380979331	Bioinformatics Computing	Books	5	6	6	N	N	Comprehensive Introduction to the filed of Bioinformatics	Bergeron wrote this book such that if you have a computer background, you can relate to the topic at hand, and if you have a biology background, you can pick up the material quickly.  He uses one to teach the other, and does so rather comprehensively.  Major topics and areas of interests in bioinformatics are covered, such as: <br />* Databases <br />* Networks and the Internet <br />* Bioinformatics search engines <br />* Data mining techniques <br />* Statistics <br />* Pattern Matching <br />* Simulation techniques and modeling <br /> <br />Any of these topics deserve a volume of books dedicated to them, but the author gives the readers enough information that can be useful in determining where to go next.  Even though the topics are mostly computing related, the author takes a great care at talking about these topics in the context of Bioinformatics.  He even lists the specific applications of each topic at the beginning of each chapter to aid the reader in relating to the topic at hand.  For example, after reading the chapter on modeling and simulation, you would know that modeling is used to determine the efficacy of drugs and to determine drug side effects during the drug discovery process.   <br /> <br />Databases are probably one of the most important and well known tools in Bioinformatics.  The enormous amount of data available for analysis requires large and fast databases.  In fact, the amount of data in bioinformatics doubles every eighteen months, so databases and database design is an integral part of bioinformatics computing.  In addition to the vast amount of raw data (sequence data and protein data for example) that is stores in databases, the analysis such as pattern matching, simulation and visualization of data requires constant access to databases.  The author talks about what are know as primary databases, databases that are used to store raw data, and other value added databases, the one's that store analyzed and/or verified data.  One thingthat reader gets out databases is the realization of what the data life cycle is in the bioinformatics world, and how it affects all the application areas of bioinformatics. <br /> <br />The databases around the world are either somehow integrated together ease the task of data discovery and data mining.  Due to the vast amount of information available, various data mining techniques have been developed over the years to assist in finding the data that a researcher is looking for.  Tasks such as data enrichment, missing value analysis for sequence data, data characterization and data distribution analysis mark some of the tasks that data mining techniques needs to accomplish.  A number of data mining techniques such as hidden Markov Models, Decision Trees, Neural Networks  and Genetic Algorithms are talked about and the pro's and con's of each one is discusses in detail.  A bioinformatician needs to be at least aware of the various data mining techniques and should have an overview how they work and why they work in general.   <br /> <br />After the data has been discovered, a method of visualization that can get the point across, per se, needs to be used.  Visualization and simulation techniques are talked about to show the reader what a bioinformatician needs to do with the information found.  There are a number of graphical tools available out there, some free and some not, that are used heavily in this business to aid the understanding of the vast amount of information that is available.  Various modeling techniques are being used today to aid with the drug discovery process and figuring out the side effect of newly developed drugs.  I would say that this area of bioinformatics will see the most growth in the coming years, and the author, Bryan Bergeron, does a great job discussing this topic.   <br /> <br />Statistics is another technique used heavily in bioinformatics computing.  Even though most of the statistical tools, Matlab and many others, have been usedfor a number of years, one must know the theory and reason behind using numerous statistical techniques in Bioinformatics.  These techniques are integrated into bioinformatics search engines and the software applications for modeling and simulations, but one still needs to know how they work.  Bioinformatics is a new field of study, and not by any means been perfected, so there are still a number research track and advancements that are still untapped, thus making the theory behind how some of the available tools work very important in this field.   <br /> <br />Bryn Bergeron in Bioinformatics Computing gives the necessary background for anyone interested in the field of bioinformatics.  After reading this book, a reader can get a good idea of which area s/he wants to pursue further.  The topics are broken into logical units that can aid the reader in realizing what specific field of bioinformatics is more interesting than others.   <br /> <br />Even if you don't decide to pickup one of many advanced books in this topic, you should know about an industry that is growing rapidly, and Bergeron's book can aid you to do just that.   <br /> <br />	2004-12-07
US	50487699	R1BILV4AQQ1BEF	0321159608	754264166	IP Storage Networking: Straight to the Core	Books	5	0	1	N	N	A good mix of technical and business information	Gary Orenstein explains the world of storage and it does so from two perspectives: technical and business.  He starts with the ins and outs of various storage technologies, and delves into why one should choose one over the other.  He speaks to the technical folks that want to perhaps move their enterprise toward an IP storage technology, and he speaks to the buyers that need to convince their managers to plunge thousands of dollars on storage technology.  Storage is becoming a multi-billion industry all into itself and it all has happened in over a decade.  The vast amount of storage required in virtually any industry from finance to life sciences to the military, requires the storage industry to move at a rapid pass, and for the IT managers to keep up with a very fast moving industry.   <br />It is not easy, however, to keep up without some help.  Orenstein's IP Storage Networking does just that, which is to provide a detailed overview of the technology and the industry.  After the overview and background on storage hardware and software, the author quickly goes into building effective storage network roadmaps.  The reader quickly learns the differences between Direct Attached Storage (DAS), Network Attached Storage (NAS) and Storage Area Networks (SAN).  The difference between file-based storage of NAS and block layer storage of SAN is discussed in detail, and the reader is made aware of the situations where one is preferred over the other.  The author really pushing for IP based storage (SAN), where the core IP network infrastructure already in place can be used.  The histories of these different technologies are also interesting.  The intelligence of storage has moved from server platforms to disk subsystems and with IP storage, to within the network layer fabric.  This allows the end systems to be rather dumb, and the already in place infrastructure to be utilized further.  The problem arises when the current Fibre Channel protocol of NAS needs to be upgradedto an iSCSI or iFCP, which are IP-based protocols.  Traditional NAS is more flexible because it is OS and file system type independent, but DAS is more optimized and faster because it is attached to the server.  SAN fits into the sweet spot between the two, but a traditionally relies on a Fibre Channel protocol for communication.  This is where the IP storage protocols come into play as they try to standardize on the communication backbone and infrastructure, and still be able to keep up with the demand.  The good news is that Gigabit and 10Gig Ethernet are on the horizon, and are able to meet the needs of SAN storage.  The issue then becomes migration paths and plans to IT managers, and the authors spends a great deal of time on that topic.   <br /> <br />One of the key things that managers need to keep in mind is that their IP connectivity infrastructure goes hand in hand with their IP storage infrastructure in the future.  The good advantage of this model is that administration and maintenance will be simpler goes forward, but the current state of the enterprise maybe far from that point.  Fibre Channel protocols may already be in place, and ripping it out maybe costly.  A phased approach is suggested throughout the book for such scenarios, and options such as gateways, routers, switches that can translate one to the other are explored in detail.   <br />Let us not loose focus on why we are spending all this money on storage technology: we want to achieve business continuity.  Well, there are six different patterns that the author explores in his book:  <br />1. Simple backup of data  <br />2. Disk redundancy where the data is stored more than once <br />3. Failover where there are at least two of everything <br />4. Point-in-time copy where check-pointing of data takes place as data changes <br />5. Wide-area replication where the entire data center can failover to another site upon a disaster <br />6. Wide-area replication and failover where the backup site can literally pickup where the primary left off.   <br /> <br />As you can imagine, simply talking about business continuity is no longer enough.  The 24/7 scenario takes an entire new meaning with each one of these architectural patterns, and the business mangers and IT architects need to balance the cost versus ROI at every step of way.  As we move to the scenarios where Wide-area networking plays a role, the author shows a dramatic increase in cost and complexity.  Now we have to calculate the Round Trip Time of data, and congestion on a connection between two sites, which we may have little or not control over.   <br />I would recommend this book to any IT manager, architect and designer that need to come up to speed with the fast pass world of storage technology.   <br />	2004-11-17
US	50487699	R3T8ZGE2EDJ66	0321245830	793177435	Java Software Solutions: Foundations of Program Design (4th Edition) (Addison-Wesley's Codemate)	Books	5	6	6	N	N	Java illustrated thoroughly for first year students	Java is arguably the best computer language to use when teaching programming, especially for first year Computer Science students.  This is mainly due to the fact that Java is easy to learn, widely available and most importantly free to use.  For first year students who are just getting their feet wet, and trying to break into the complex and vast field of Computer Science, Java's wide acceptance in the real-world is certainly a big plus.  But Java does have its flaws, and one of which is caused by the fact that it is free to use.  Java is big, very big.  A professional would have to spend his entire career trying to learn Java and its related technology in its fullness.  For most professionals, however, one section is enough to build our careers on, whether it being Server Side Java, GUI and front-end, Wireless Java, Enterprise Java, Messaging, etc...  The point is, if one is to understand and learn some of these advanced topics, one needs a good foundation and understanding of the core Java programming language.   <br /> <br />Java Software Solutions by Lewis and Loftus IS that book.  This book is self contained and had everything a first year Computer Science student would ever need.  As I mentioned, Java is very big and there are lots of information available out there that a newbie would need to spend an unprecedented amount of hours making sense out of all the available information on this topic.  The book contains the necessary Java API - the one's that were used in the book and some extra one's that are needed, so the student does not have to spend extra time searching for something rather trivial.  The same goes for Regular Expressions, JavaDoc usage, GUI event handling procedures and many others.  I agree that students need to be prepared and have to know how to find these types of information, but wouldn't you, as the instructor, like to have the option of not having to spend your lecture time telling your students where to download JavaDoc's usage guides?  Wouldn't you, as the student, like to have all the necessary information you need at the tip of your fingers instead of having to search for something new all the time?  This book is well packed with all the necessary and extra information required for the first time newbie students going thru a programming class.  For someone new, having to learn to program and all the new concepts and terms is overwhelming, and it is rather nice to be able to go to the end of the book and get the information you need.  The book also gives enough background and introduction to the topic that even a person new to computers can come up to speed with all the necessary information to get going with topic at hand.   <br /> <br />How about the rest of the book?  In one phrase, this book is well illustrated.  That's right, illustrated.  Code snippets, examples from simple to a large and rather complicated \\"PaintBox\\" project, using figures and graphs to demonstrate program flow and language syntax and inserting program outputs right after the program source code for easy access mark some of the illustrations of this book.  The end of each chapter is used to wrap up the topic just covered with a \\"summary of key concepts\\" area, which is very thorough in fact, followed by \\"Self review questions\\", \\"Exercises\\" and \\"Programming projects.\\"  The answers to the \\"Self review questions\\" are given, and the exercises and the programming projects at the end of the chapter can be used by the instructors to further educate and teach the Java programming language to their students.  Since this book is also CodeMate \\"enabled\\", which means students can view, compile, run, and edit select programming problems and all code listings from the text book.   <br /> <br />If you want your students to succeed as Software Engineers or even good programmers, you need to start them of on a good foundation of Software Engineering best practices and sound engineering and programming guidelines and methodologies.  Lewisand Loftus's Java Software Solutions promote best practices and object oriented techniques and methodologies throughout their book.  Either it being simple UML class diagrams to further illustrate the design, talking about inheritance and why it's required or even coding guidelines and code documentation, this book it field with the necessary tools, techniques and methodologies to get your first year Computer Science students on the right track.   <br /> <br />This book also comes with the required slides, tests, lab manual, solutions set and instruction's manual to aid the instructors in their teaching, and a CD packed with the source code, the latest Java (J2SE 1.5) and tools and goodies used throughout the book for the students.   <br />	2004-08-16
US	50487699	R31W63IW4Y47AT	0321136179	2242900	The XML Schema Companion	Books	5	4	7	N	N	From beginning to the end, XML Schema is explained	Neil Bradley in his fourth book tells you everything you would ever want to know about XML Schemas or better knows as XSD for XML Schema Definition.  With the popularity that various XML technologies are attracting these days, every developer, architect and designer needs to know what XML Schema is and how it used.  This topic is covered in many other books, but Bradley's book has by far the most extensive, comprehensive and thorough coverage of the topic.  It shows that author truly understand the topic at hand, and can convey the message clearly to the reader.  The organization of the book starts with the author explaining how the XML Schema standard defines a template that documents created based on that template must conform to, followed by showing the reader how to define reusable data blocks based on the XML Schema language, and it finishes with XML Schema related topic such as namespaces and a rather complete overview what's out there and where to get more information.   <br /> <br />Schemas are in a whole different category all by themselves.  Every XML document, standard, protocol - basically anything that has anything to do with XML needs to use or to interact with XML Schema in one or another. XML Schemas are used to model both data and narrative XML documents, which means that if you are ever planning on interacting with XML, you better understand XML schemas.  I thought that this topic will be very easy, and there is nothing to it... I was wrong.  There is a whole lot to cover and once you read Bradley's book you'll know what I am talking about.  The standard for schemas is so extensive, that the first few chapters of his book are spent on what the different terminologies mean and how they interrelate.  For example, the difference between narrative data (data where the sequence of events and representation matters greatly) and datacenteric documents (order of presenting the data does not matter), and the difference between the schema definition author (the person who creates the schemas) versus the document instance author (people who create well-formed documents) and many others alike.  After talking about the basics, the author spends a great deal of time explaining the various components of the XML schema such as elements, attributes, simple data type, complex data types, etc...  Understanding these topics is essential in reading the following chapters of the book.   <br />The author uses the same examples throughout the end, so the reader can follow the text and actually understand the topic while the author is presenting it.  The code samples are just great.  Since the topic is rather abstract, the author had spent a great deal of time using examples to demonstrate the topic at hand better.  There were times that I read the example first, and then I went back to read the text, because the visualization is the key in this topic.  As with any programming or technical book, the topic and examples start simple and they get much harder as you read the book.  The same goes with this book, but the interesting thing is that if you don't know enough about namespaces, the author sends you off to one of the accompanying chapters to read to get ready.  The chances are that you don't know enough about namespaces, and the \\"reference\\" topics included towards the end of the book become very valuable as you read this book.  I thought that I knew namespaces rather well until I read the following: <br />\\"... namespaces do not exist as physical entities.  There is no namespace definition markup language and no namespace file, object, or interface.  ...  namespaces are just a concept.  This fact alone has led to much unnecessary confusion...\\" <br />In all the books and all the articles and the press and ... that I have read on XML, this little but rather important concept was left out.  In one chapter the author has shed more light on a topic of namespaces than an entire book that one would find on the topic.  The moral of the story is to read this book cover-to-cover.  Even if you think you know it all, still spend the time to read this book.  I was amazed at how complicated XML Schemas could get and how powerful they really are.   <br />Some of the advanced topics covered include inheritance and pattern recognition.  Both topics are very well explained and covered well.  If you know regular expression from Perl, then pattern recognition in schema world would look very familiar to you.  The same regular expression rules that are covered in Perl, govern the patterns matching in XML Schemas.  What the author adds is concrete examples of how this technique can be used to build powerful schemas.  Inheritance is another interesting topic in schemas, as inheritance has made XML schemas very object oriented.  Some of your favorite concepts in Java map directly into schemas, and the author actually made table cross referencing the various \\"key phrases\\" in Java versus XML Schemas.  If you are coming from the OO world of C++ or Java, take a look at this table first.  If you are at all familiar with the Eiffel language, you would have a greater appreciation for some of the features of XML Schemas such as the ability to redefine an element or to extend specific parts of a schema.   <br />In closing, if you think you know XML Schema's, think again.  This book covers the topic in detail and does so very well.  I would recommend this book to be read by any schema designer or a valuable reference for anyone interface with any XML technology.   <br /> <br /> <br /> <br />	2004-08-15
US	50487699	RJNRAI5BJRESM	0131411543	215462730	Advanced UNIX Programming (2nd Edition)	Books	5	43	43	N	N	Required Reading for UNIX developers	This book is truly exceptional - it covered the UNIX programming environment from beginning to the end very well.  Marc Rochkind has done an amazing job updating his classic book.   <br />A brief history of UNIX and a history of various UNIX standards such as POSIX, SUS and pretty much all the others plus a 30 minute crash course in the underlying structure of UNIX get the readers going.  If you are anything like me that hasn't as much a thought about how process ID's are used and the creation child processes and how permission plays a role in process creation, you will enjoy this section.  I learned that its one thing to \\"use\\" UNIX, and another to really understand it deep down.  The standards that are out there really throws you off though as there are so many of them.  How and which one to choose? It gets rather complicated.  Marc spends the first section talking about all the difficulties of \\"choosing a standard\\", and then gives you a header file that you can plug into your code and off you go.  I was pleased by that.  I have already started using that header file in my code and I find it rather useful.   <br /> <br />Starting from the basics of files and file access, every one of the function calls are depicted in full and example is given for each one of them.  This book is like a big \\"how-to\\" notebook that one can pick and choose what to read where to get valuable information from as one needs it.  Another thing that the author does throughout his book, which made me very happy, was the little tables of \\"stats comparisons\\" between the various options and settings that were just discussed.  No more guessing games as to what to expect or what to test.  It's all right there.  I know, for example, that blocked-sized I/O of 512 bytes takes less than a second to complete versus 223 seconds when a character at a time is read.  You might think that this information is rather trivial, but do you know the difference in the time that it takes to access data stored in aregular file versus data stored on a raw disk device?   <br /> <br />Accessing the terminal can get rather complicated with all the options available, and I didn't know was how much more complicated this matter gets due to the relations that terminals have with sessions and process groups.  Process group, session leader, process-group leader and the controlling process could make you life as a programmer very difficult if you don't know how they inter-relate.  The power of UNIX comes in a box - you have to open it to see inside, but be very prepared before you open up that box.   <br />If you have done any network programming if your life, you want to know the details and options that are available to you if you are using \\"select\\" or \\"pselelct\\".  What the timeout options are, and how you can use the \\"poll\\" system call to achieve the same task as \\"select\\", but more efficiently at times.    <br /> <br />Threads, Processes and their inner workings are covered extensively in this book, as one would assume.  The difference in this author's explanation of these two topics is the presentation.  The author in talking about these topics, and everything else from here on, builds a fairly complete command interpreter!  Starts rather small, but by the end of the book, it is a full blown UNIX like CLI with pipelines, background processes, quoted arguments, handling of I/O redirection and accepting of environment variables.  Processes and threads start the discussion with \\"fork\\", \\"exec\\" and other similar and related function calls.  A great deal of time is spent talking bout these two rather important calls, and how they are used, options, inheritance of those options, and programming hints and examples for each one of them.  Threads and synchronization of threads via mutex and conditional variables are the next topic if discussion.  Threads could get a bit more complicated, so you should spend a bit more time reading this section.  The author starts you of easy though.  No mutexor race conditions are considered at first.  It then gets rather interesting with the various race conditions that the authors has the reader think thru.   <br /> <br />Communication between threads processes have always been an interesting topic to cover.  Pipes, names pipes, shared memory and sockets.  Pipes are rather easy.  They have their limitations, which are discussed in full, but they are rather easy.  Names pipes (queues) and unidirectional pipes get the reader going, if you have not done any Interprocess Communication before.  Even if you have, it's good to revisit something that is not really used these days.  Messages, semaphores, sockets and shared memory are covered in a great depth by the author.  What I absolutely love about this book comes in these later sections of the book.  Marc, in depicting these topics and sections builds, from scratch, what could essentially be called a middleware - Simple Messaging Interface (SMI) he calls it.   <br /> <br />SMI is probably one of the best book examples I have seen.  Besides the fact that it is very useful and practical all into itself, it also promotes good network programming practice.  SMI is first implemented with Names Pipes or FIFOs, then using Message Queues, then Semaphores and finally via Shared Memory.  Very well done Marc.  If that's not enough, all of the implementations are compared with each other, and pros and cons of each one is given to aid a developer or a designer in choosing the right methodology.   <br /> <br />The Simple Socket Interface is the Socket implementation version of the SMI.  Again, very well done and prescribed by the author.  Besides being very good teaching tools, they are also very practical and useful; something that we are should have in our toolbox.   <br /> <br />I highly recommend this book to any developer; designer or an architect as it is very good teaching aid for all.  <br /> <br />	2004-08-06
US	50487699	R1H4LYXH74AV8P	0201760428	722219002	Exceptional C++ Style: 40 New Engineering Puzzles, Programming Problems, and Solutions	Books	5	27	29	N	N	Simply exceptional	Did you know the \\"snprinf(...)\\" that we use in our programs is not part of the C++ standard?  Did you know that the \\"export\\" keyword has little or no benefit to C++ templates and the source code of the implementation still needs to be shipped?  Do you know what primary templates are?  Did you know that Accessibility checking is the last things a compiler checks for - after checking for overload resolution?  Do you make your virtual functions private? Well, you really should.  Do you know what Herb Sutter's favorite Starbucks drink is?  Do you know what the \\"const\\" keyword really buys you?  How about inline-ing?   <br /> <br />If you answered no to even one of these questions, you should read Herb Sutter's Exceptional C++ Style, 40 New Engineering Puzzles, Programming Problems, and Solutions book.  I must say that I am not doing justice in reviewing this book, since each item in this 40 item collection should really reviewed independently as each one is very well written, useful and practical.   <br /> <br />To start, this book is well organized into sections as one would expect such type of organization with book of such type.  One differing aspect is with the Case Studies at the end of the book.  Mostly around the string class, but nonetheless, they are very informative.  The author has taken already-out-there-being-used code and depicts them for their style.  Various \\"guidelines\\" given by the author in the Case Studies section makes the developer's life a whole lot simpler.  One of my favorite guidelines - throughout the book - is the one the author gives about the decision that each developer goes thru when designing a class and wants to make a decision about what to make friend, a member and a non-member of a class: <br />- Always make it a member if it has to be one.   <br />- Prefer to make it a member if it needs access to internals <br />- In all other cases, prefer to make it a non-member friend.   <br />Simple?  Well, it should be.  There are plenty of explanation and example for each of the given guidelines.  As one reads and understands the given guidelines, they are very easy memorize-able.  Three small phrases which we call have used or even know when we write code, but they are all on paper and are made very simple to be carved in one's memory.  The author makes a great deal of effort to follow this routine, an engineering approach to solving problems and designing software, throughout the book.  This book is like having an engineering notebook with fun-facts and pointers and hints that you always wanted to know and now you do! <br /> <br />I should really have gone thru the book in some sort of a chronological order, but I figured that the Case Studies are rather unique in this book and require special attention.   <br /> <br />Who would have thought that there is so much to the Standard Template Libraries?  Did you know that there are functions/methods in the STL that one can not even use with the STL?  (Item 4)  \\"...the bottom line is that you can't reliably form pointers to standard library member functions and still have portable code.\\"  I was blown away by this bold statement.  What do you mean?  You want to tell me that standard doesn't really constitute a standard?  Want to tell me that my code that I have been so carefully writing using the STL might not be portable after all?  There are rather amazing twists in the C++ language, and the author elegantly describes these abnormalities, and it the process the author manages to blow your mind away. <br /> <br />A great amount of attention is given throughout the book to the \\"boost\\" libraries.  I was not familiar with \\"boost\\", and I was interested enough after reading this book that I will make a point to read up on it.  The author does make a claim that the boost library might become part of the C++ standard, which would explain why the author has referred to the boost library so much in his text.  A good deal of attention was also given to Inheritance andPolymorphism as one would expect.  You see this topic all the time in every C++ book, but there are still grounds uncovered and stones unturned.  You can't ever have enough of this specific topic.  The most intriguing part is Item 16 about a class's Private Parts!  If you think that Private members are really hidden, then think again and read Item 16 - you will be amazed at how the C++ compiler treats private members and methods.   <br /> <br />Virtuality and virtual classes: you know them as the cause of needing to stay at work late to debug your code, and the reason behind male pattern baldness due to the stress that they cause you.  If this is the least bit true, then Item 18 is for you.  The best quote out of this item is made when the author talks about public virtual functions: \\"Prefer to make virtual functions private.\\" Why you ask?  Read Item 18 and find out.   <br /> <br />A wealth of information is in this book.  Herb Sutter has done it again.  This book is a must for every C++ programmer as it further unleashes the great power and flexibility of the C++ programming language. <br /> <br /> <br />	2004-08-05
US	50487699	RFNLGGUWH4FRC	0201709279	488970031	Absolute C++	Books	5	20	20	N	N	Truly a well written college text book	Walter Savitch, the author of the Absolute C++, first edition, has done an amazing job putting together a book that can be used as a teaching aid for second year or first year advanced Computer Science students.  Unlike professional books, the author has geared this book towards students with little programming experience in the real-world at least, and has created problems that can aid the student in learning the material more deeply and more concretely.  If I were an instructor, this would the book that I would use, and if I had to take C++ all over again, this is the book I would love to learn from.<br />Color aids and categorized notes, such as \\"Pitfall\\" and \\"Tip\\", aid the student along the way with little details that go a long way when you are programming.  \\"Example\\" and \\"Self-test exercises\\" further the learning process after each section by testing the student's knowledge of the topic.  At the end of each chapter answers are given to the \\"self-test exercises\\" and various programming projects are given that mimic the topic covered and at the same time expect the student to think outside of the box to solve the problems.  Some of the programming projects given are hard enough that they can used - alone or collectively with other problems in other chapters - as semester long projects or group projects.  <BR>Examples are depicted right on spot rather than line-by-line after the example.  Colored notes, arrows to the section of code being explained and highlighting of the important code sections are used to depict each and every example.  The examples are well-documented and various \\"screen shots\\" are used to display what the output would look like.  Pictures are inserted when needed, explaining how pointers and references work for example, and they are worth a thousand words.  The pictures are easily concise and clear, simple and yet to the point.  <br />Being a text book on C++, one would wonder about the authors approach to the C++ language.  It would help ifthe readers on this book have some background on programming, and especially in C++.  The author spends one chapter on the basics of the language, but that's not enough for readers with no programming background.  A good deal is then devoted to various aspects of programming such as arrays, functions and structures first before the author starts on the in-depth coverage of C++ itself.  The Standard Template Library (STL) is used throughout the book to demonstrate and teach C++, starting with Vectors.  Each of the classes of the STL are covered in detail throughout the book, but the authors breaks each of the major classes (lists, string, vector, etc...) and places them to teach a specific topic to the students.  The author touches on STL first before going in to operator overloading, for example.  This way, the students can learn the [semi] advanced features of the language in a context in which it can later be used - more concrete and more applied approach rather than an abstract overview of the features.  With that pattern, the string class is covered first before the author starts on pointers, array of pointers, character pointers and pointer and reference manipulation in general.  <br />More advanced topics in C++ such as virtual functions, inheritance, templates and exceptions are covered towards the last half of the book.  Templates being a rather interesting and possibly complicated topic are covered before the STL container classes such as linked lists and trees are covered.  Not too much detail is given on templates and only the basics, as one would expect.  Templates are covered just enough to get the students to understand how linked lists work, or how function templates are used in the STL, for example.  UML and Patterns?  They are covered too.  Not in detail, but enough for a lecture or two at the end of the semester.  Model-View-Controller, the classic of all patterns is covered first, and examples from the book are used to convey the message and the power of templates.  <BR>In closing, I wanted to touch on the web site for the book, and instructions material that is available for this book.  Obviously all of the source code from the book is available for download, along with the slides for the students.  For instructors, the slides are simply great.  What reinvent the wheel?  Simply use Savitch's slides for teaching.  Example tests are also available for the instructors.  If that wasn't enough, the CD in the book comes with an introductory version of the Visual C++ 6.0 to be used by the students.  The package (website, CD-Rom and the book) is simply complete!  <BR>I would highly recommend this book to any instructor of the C++ programming language.	2004-07-09
US	50487699	R2MUWRB1OZPF3N	0201703599	508025051	XML Family of Specifications: A Practical Guide (2 Vol Set)	Books	5	2	2	N	N	Rather practical!	Where to start?  With the concise history of where XML came from and why each design decision was made and how the evolution of specifications took place over the years, or the thorough explanation of all the XML specifications, or the programming and parsing aspects of XML and metadata, or the cool XML timeline poster towards the end of the book?  This book has much to offer any person interested in finding out what XML is and why and how it has changed our world.  <br />Kenneth B. Sall, the author of this book, organized this book in a fashion where each section could be studied on its own, and if there are references to the previous sections, they are appropriately mentioned.  This way, one does not need to sit down and cover this 1000+ page book cover to cover to realize that the topic of conversation is.  The stage is set at the beginning by the author commenting on the fact that XML can describe everything under the sun, even the kitchen sink:<br />\\"XML: ... maybe it's everything but the kitchen sink? Say, have you heard the one about the XML Kitchen Sink Language? ...\\"<br />I have been working with XML for sometime now, and I am still amazed at how it has grown and expanded in to our everyday lives in the past few years.  One can spend months coming up to speed with the specifications and the XML \\"realm\\", and that's not enough.  This book does not even cover, in a great detail at least, the Web services realm.  That alone is a couple of thousand page book.  The background topics are essential to any reader: basic XML syntax, DTD, Canonical XML, Namespaces and XML Schema.  Once you have these topics covered and well understood, you can jump around to any other part of the book, displaying XML data for example or XML programming API's.  <br />One can spend a couple of hours trying to figure out how these specifications fit in, but the author hs already done the job with a very useful picture inside the cover page.  What's your forte?  Cascading Style Sheets toconvert XML data into a PDF document for example, or an XHTML document to display on a web site? XHTML is also covered in length, if you do not know that is and what it offers over the plain old HTML.<BR>My favorite topics were probably the authors explanation of the XML parsing and the available API's and resources.  SAX, DOM, JAXP and JDOM are covered in great detail.  <BR>* SAX - the API that started it all.  Minimal and light-weight. Fast and event driven.<BR>* DOM - Memory intensive, complex, but very powerful.  It's a tree based model, and the tree represents the whole document.  <BR>* JDOM - java specific.  Can be used with either DOM or SAX.<BR>* JAXP - java specific again, but easier to use than JDOM.  <BR>There are also a number of C++ XML parsers that the author touches on such as the Apache Xerces, C++ SAX and many others, but the main topics revolve around the four most popular parsers mentioned.  These sections are mostly tutorials and how-to's.  Each parser is used in an example and example is analyzed piece by piece.  DOM is covered in more detail due to the number of levels (DOM level 1-3) that it has.  Since DOM is more powerful and more complicated, the topic is a bit more advanced and would require more attention from a novice.  If you read thru the SAX chapter and understand it well, DOM would not be that much of hurtle, but make sure that you read understand SAX first.  Java centric API's including XML-RPC, JAXB, JDOM, JAXM are covered by the author to depict how XML can be used and how it would benefit the application - and developers in-turn.  The icing on the cake is when K. B. Sall outlines the differences between SAX, DOM, JDOM and JSAX.  He talks about each of the technologies in detail, tell you what the advantage and disadvantage of each one is, and then it compares them against each other.  By the time you are done reading these sections, you would become an expert in XML parsing and programming.  <br />XLink and XPointer.  How can oneleave without these two core technologies and tools?  They are truly remarkable; easy to use, light weight and easy to learn.  Well, they are well covered - as you would expect from this book.  One thing about these topics is that they could be very abstract and need examples, and we got lots of those.  The example depict the efficacy of how one can use XLink to create complex connections between sets of resources, even though you do not have a write access to those resources.  This is very handy and resourceful technique is you need to build an e-commerce site.  With XPointer, one can locate individual XML elements, set of elements or even a range of XML data between two points.  The ability to specify \\"range\\" of elements is where the true power of XPointer is revealed.  <br />The references, the related resources for each topic, simple to complicated examples and a CD filled with goodies, source code used throughout the book and the W3C specifications at your fingertips outline the some of the other benefits of Kenneth B. Sall's \\"XML Family of Specifications\\" book.	2004-07-04
US	50487699	R2IT41X1P7EZAL	0130353132	215750353	Thinking in C++, Volume 2: Practical Programming	Books	5	32	36	N	N	The only other C++ book you would need	There are plenty of C++ books out there.  When it comes down to it, one would really need two books on C++.  Well, this is the second book you need; with the first one being any of many classics including the first volume of this book.  Just when you think you have read or have a reference to all the C++ topics, Eckel and Allison come out with their continuation of a classic - volume two of Thinking in C++.  <br />Exceptions, Templates, STL, Design Patterns, Multiple Inheritance, concurrency and parallel programming are just some of the main topics covered in this book.  With the book being over 800 pages, one can imagine how deep each of these topics must have been covered.  Exceptions grab you right off the bat.  Just when you think you know all about exceptions, the authors throw you a curve ball with \\"Exception Specification\\", and how to handle the \\"unexpected\\".  You are blown away by the true control that C++ gives you.  . <BR>Strings, along with examples given to depict the string class in full - as part of the standard template library (STL) of C++, begin the authors' discussion of the Standard Template Library.  Vectors, sets, lists and many other features of the STL have their own dedicated section which talks about generic containers.  The authors set the stage for STL by describing the containers as:<br />\\"Container classes are the solution to a specific kind of code reuse problem. ...A container class describes an object that holds other objects...\\"<br />The authors then continue on to cover the very important and broad topic in C++ - containers.  Examples after examples are used to convey the details and the tricky parts of the C++ STL.  The key by reading this chapter is to portray and teach efficient techniques to common problems using the generic container classes.  Not only the reader can learn most of what s/he needs to know about containers in this book, a small introduction is also given to show how to actually write a generic container - a linked list.  The example is simple, yet powerful in conveying to the reader the ins and outs of writing generic containers.  Speaking of generic, generic algorithms are covered very well in this book.  All of the algorithms currently in the C++ library are covered with an accompanying example for each one.  A special attention is given to the use of function objects as the means of customizing these algorithms.  <br />\\"A function object is an instance of a class that overloads operator(), the function call operator.  This operator allows an object to be used with function call syntax\\"<br />Probably the simplest and the easiest definition of algorithm complexity theory is given in this book.  The authors make the concept so easy to understand that even a non-programmer or mathematician can understand the reason and the complexity of complexity theory!  <BR>Templates are probably my favorite topics in this book.  Next to the C++ template \\"bible\\" by Vaqndervoorde and Josuttis, this book is the best source for generic programming and templates.  The authors cover the three main topics of templates well: <BR>1) Templates with types as parameters<BR>2) Templates with compile-time constant as values<BR>3) Templates with other templates as values.  <BR>The authors start with small and simple examples and build on top of them.  Templates are generally a difficult topics to cover and to convey, but the authors do a great job in depicting the examples and teaching the reader how templates work and to create powerful programs with them.  <BR>The advanced topics in this book (multiple inheritance, runtime type identification, design patterns, and concurrent programming) are my favorite topics.  Multiple Inheritance is covered in depth, better than any other book that I have seen out there.  The authors do caution the readers regarding the difficulties and the pitfalls of multiple inheritance, but they also explain with examples, pictures, etc... how a developer can overcome these difficulties (using upcast to resolve naming conflicts for example or avoiding the diamond-shaped inheritance tree).<BR>Concurrency and concurrent programming is one of the more difficult things to do in C++.  Threads are usually used to achieve such task, but it takes practice and lots of sleepless nights to debug threaded programs and resolve deadlock issues with threads.  The advantages of threads (ability to run multiple tasks concurrently, very low context switching relative to processes, allow better code organization and the added convenience to the user specially for graphical user interface tasks) are depicted and shown thru a number of examples.  The most important part of this section is how the authors use examples to show what the right way of doing something is as oppose to simply putting bunch of source code together to fill in the blank pages.  The examples are priceless to me and very beneficial to any programmer.<br />All and all, Bruce Eckel and Chuck Allison did a great job putting this book together.  The topics covered are very beneficial to any serious C++ programmer or anyone wishing to become one.  I particularly like the examples and \\"how-to's\\" given throughout the book as they are a valuable source when I am stuck with a programming challenge.	2004-06-04
US	50487699	R2T8DYC4HBRYTP	0321193687	701144034	UML Distilled: A Brief Guide to the Standard Object Modeling Language (3rd Edition)	Books	5	3	4	N	N	: Good introductory book that covers the basics well	A good mixture of UML, new additions to UML and how UML integrates into software processes.  The topics are at a high level and only get skin deep, so this book is good for practically anyone interested in UML: developers needing to know the new additions to UML, managers with little time that want to learn UML to be able to talk to their developers, and even marketing staff wanting to communicate the needs of their customers with the engineers and product managers.  <br />Martin Fowler has done it again with the third edition of the UML Distilled book.  Informative, well organized, quick read and more importantly an easy read.  He starts with a background on UML and where it came from, and where it is currently heading.  He continues with the introduction with going over what a software process is and why it's needed.  The importance and the benefits of how UML can assist the software process during all the phases of the process sets the stage for UML throughout the rest of the book.  If you are unfamiliar with software processes such as the Rational Unified Process, Fowler's introduction goes a long way and clear things up.  <br />\\"... the creators of the UML see the [UML] diagrams as a secondary; the essence of the UML is the meta model.  Diagrams are simply a presentation of the meta-model.\\"  <br />Probably the best explanation of UML you can find anywhere.  Folwer, from the get go tries to set the stage straight and clear up some of the misconceptions that UML.  At the beginning, he focuses on the fact that UML is not the solution to everything a development team faces during a project, but rather a starting point, and \\"you shouldn't hesitate to use a non-UML diagram if no UML diagram suits your purpose.\\"<br />Starting with the basics of UML, such as class diagrams and sequence diagrams, Fowler delves into the basics of UML and mainly the critical components on UML 1.0.  A very controversial topic in UML and mainly the class diagrams are the notion of Aggregation and Composition.  Aggregation being the part-of relationship and composition being an object with only one owner are depicted well thru a number of examples.  For simplicity, Fowler suggests the aggregation be entirely dropped from diagrams.<BR>Associations versus class Properties are another unclear point that is covered well.  If you have been working with UML for a while, you have certainly realized that anything that can be presented via Associations can also be presented via the use of Properties.  This point of ambiguity could mean the difference between a clean and clear class diagram and a clotted diagram that looks like a web of coupled classes.  The author clears the point between the two notions up by specifying a rule of thumb:  use attributes for small things such as dates and Boolean types, and use associations between large object types with clear dependencies between the objects.  This rule can certainly help when you are trying to do round-trip-engineering, and your reversed engineered class diagram is totally not what you were expecting!  Has that ever happened to you?  <BR>Object Diagrams, Use Cases, State Machines and Activity diagrams mark some of the UML tools that have been around since the earlier versions of UML.  <BR>Composite Structures, Interaction Overview and Timing Diagrams are new to the UML 2.0.  Composite Structures enable the internal structure of a class to be decomposed.  It clearly defines and marks what the interfaces are, and what the required external interfaces are for each of the interfaces shown.  Interaction Overview diagrams graft together activity diagrams and sequence diagrams.  The author does however mention that he has no interest in using the Interaction Overview diagram due to the fact that they are too busy.  I agree!<BR>Overall, Martin Fowler's UML Distilled book provides a clear, concise and brief but sweet introduction to UML.  Each topic is short and gets to the point.  Main pitfall of UML are explained well, and the reader upon reading this book can \\"speak\\" the UML language.	2004-05-07
US	50487699	R2O71LUY09N3UX	0130497657	4644794	Charles F. Goldfarb's XML Handbook (5th Edition) (Charles F. Goldfarb Definitive XML Series)	Books	5	2	5	N	N	The One source you need to answer any question about XML	It took Charles Goldfarb, Paul Prescod and many others, sixty-seven chapters to explain all there is to know about XML and XML related technology.  This book must be the most complete reference book when it comes to XML: any thing from history of XML in Chapter 1 to VoiceXML in Chapter 46 and everything in between.  This book is filled, and each chapter is appropriately marked with, Introductory Discussions, Application Discussions, Tool Discussions, Case Studies and Friendly Tutorials.    The author has broken the book into 24 distinct parts; each part can be studies independently as they are very well contained with background information, case study and appropriate discussions.  The first part is devoted to readers who are not XML savvy, followed by three chapters of the basic XML use: Three-tier applications, E-Commerce and Integration.  It is very much amazing to me how the author packs three very important topics in to less than one hundred pages, and gets the point across.  If the topic get s a bit complicated like the chapter on Integration with the Web (chapter 13), the author quickly switches to a Case Study chapter and shows the reader how things are done by example.    \\"Content is King\\".  Reading this phrase at the beginning of Part 5 tells you that Goldfarb knows what he is talking about, because content IS king.  Content Management must be one of the best parts of this book.  A case study followed by a chapter on content systems (Chapter 16) and a chapter on what the key components of a Content Management is (chapter 17) really wheels the context in and the reader gets a very good understanding of what this growing field is all about.  \\"Content is King\\".  Content Acquisition, which is covered in Part 10, is another very well covered set of topics.  Being is a VERY complicated topic, the authors (guest authors and experts who helped with writing this section) start off by explaining what syndicators and subscribers are: Content providers and content receivers.  ICE, a new protocol for content delivery created by the ICE Authoring Group is introduced and used thru out the chapter.  The authors add:    \\"The ICE protocol defines a model for the ongoing management of syndication relationships, including the roles and responsibilities of syndicators and subscribers\\"     Using ICE:  - The syndicators can describe business rules  - The syndicators can create and manage catalogs of subscription offers  - A common format - XML, is used to exchange data between the syndicators and subscribers.  - Various delivery modes such as push or pull and frequency of delivery can be indicated by the subscribers  - The subscribers determine if content can be updated in delta format or otherwise  - The content can be received from and sent to many locations and repository types.    The authors show the power of the tool and how it can benefit the end user and their application content management needs.      \\"... If Web Services really is a revolution, it may be the first in history to be led by the parties in power.\\"    Web Services are the next set of topics covered in this book and two parts (13 and 14) are devoted to Web Services and Service Oriented Architecture.  The author starts by giving the reason and the background of where Web Services came from and why they are here. (This is very common for this author as he explains every XML technology first and gives the reason why it's here)  The good thing about this section is that Web Services have yet to be proven and the author conveys that message well:     \\"Web services is a very far-reaching and ambitious vision, with implications for all Web users and, if the goals are achieved, for much of the economy as well.\\"    The two big players in the Web Services world, mainly IBM and Microsoft helped in writing these two parts.  It is very interesting to see that for the first time in a very long time, these two rivals see eye-to-eye about a technology such as Web services.  A discussion of UDDI, the directory for discovering Web Services, WSDL, the Web Services Description Language, and SOAP are given.  The icing on the cake is chapter 41 where experts from IBM talk about Service deployment and outlines the steps that need to be taken to do such task.  The application that they deploy is very much useless, but the steps taken to deploy are priceless as they are very concise and clear.  Service Oriented Architecture, their vision, methodology and benefits are given in chapter 42.  The two main architectural patterns that are used today: service-centric design and the rich-client design are explained and are used as the groundwork to explain why SOA is a better approach to either of the two.      Jumping to the last few parts of the book where the author[s] has added tutorials of all the major topics that were discussed in the text.  XML Basics, Namespaces, DTD are just the beginning of some of the tutorials that added towards the end of this book.   Whole parts are devoted to XPath, XSLT and XSL.  XPointer also gets its own section with a chapter devoted to XLink.  The great thing about these tutorials are that they are self contained and can be read independently of any other chapter of the book.  They are quick study guides when you need them.        C. Goldfarb, Paul Prescod and many experts that were involved in putting XML Handbook together did a great job in doing so.  This book truly contains everything one needs to know about XML and XML technologies.	2004-04-13
US	50487699	RSHBZZ63V5CM8	0201773449	953624568	Operating Systems (3rd Edition)	Books	5	5	15	N	N	Very good intro book that covers a broad topic well	There are many books written on the topic of Operating Systems, but no book covers all the major and even some not so popular Operating Systems so well.  Anything from Pocket PC to Unix and Linux in detail: Distributed computing, clustered computing, virtual machines and everything in between.  Various important topics in Operating System such as File management, Memory Management including virtual memory, Security and Networking topics are discussed in detail, and popular Operating Systems frequently used today are used as examples of how each subsystem is developed.  <br />Gary Nutt starts this book by going over the basic of Operating Systems.  Its components, subsystems and more specifically what are know to be the most important component of a well established Operating System: Memory Subsystem, File System, I/O System and Process Management.  The book takes a unique approach in introducing various components of an OS to the reader.  The author assumes that the reader has some programming experience, which is a very good assumption, and instead of taking a bottom up approach, it takes a top down approach in showing the various aspects of an OS.  In Chapter 2, the student/reader is shown a multi-threaded program in Linux/Unix and Windows.  The programs in this chapter and all the subsequent chapters are used to bridge the gap between theory and actual practice in the design and implementation on an Operating System.  Other books mainly talk about the various aspects of an OS, but none really actually shows the reader/student how it actually works under the hood via programming examples, and code samples.  By the end of chapter 4, the reader has a fairly good understanding of what Operating Systems are made out of and what each component of an OS actually works, even down to the CPU level with interrupts and memory allocation.  <BR>Chapter 5 talks about Device Management: device drivers, various I/O strategies and it discusses the steps required to build be device manager.  The lab at the end of the chapter is particularly interesting as it walks the student thru building a floppy disk driver.  <BR>The next four chapters are probably the most well written chapters on Process Management.  As with the other parts of the book, the two main Operating Systems: Windows and Unix, are covered in detail and an emphasis is put on how these two OS's differ from each other and in what aspect.  The author starts by talking a little abstractly about processes, their various states and how they fit into the overall architecture of an OS.  The authors then goes into more specific details and talks about the various implementation details on Process Managers and what their job is.  This pattern continues throughout the chapter with the author spending a bit of time on various aspect of a process manager, and then going deeper into it and talking about how Unix or Windows have implemented such function.  The topic of process Synchronization which tends to be a very difficult topic to cover is probably the best written chapter in the entire book.  The author uses coding samples from the get go to discuss the topic.  The coding samples apply to Unix, but they are still very applicable to Windows.  The author step by step peels the onion and teaches the student how process sync is done in an Operating System, and how the same techniques can be used in everyday programming practices.  The labs at the end of these five chapters are very practical, as I have come across these same problems more than once in my professional life.  <BR>Memory Management is covered in the next two chapters.  Paging and segmentation are covered in detail and the two labs focus on Memory Management topic in Windows and Unix.  The interesting part about topic is that the author does not hesitate to use an old and obsolete Operating System, Multics, to convey to the reader how Memory Management is best done.  The reader does get a solid understanding of how Memory Management is done in the popular OS's, however.  <BR>File Management and Security relatively small chapter in this book.  The chapter in security is relatively a little dry, but I guess that's just the nature of the topic - not much can done about that.  Very informative chapter, nonetheless.  <BR>Distributed Computing, Middleware, Networking and Distributed Programming cover some of the advanced topics at the end of this book. Chapter 20 and 21 gets down and dirty with comparing Linux with Windows.  A head to head objective comparison of these two Operating Systems thru two case studies.  I found these two chapters to be a very good closing to this book, as there is so much controversy surrounding these two OS's.  <BR>Overall, Gary Nutt has done a great job putting this textbook together.  The organization, examples, labs and more importantly the contents are well worth the read.  A students, this might be the best book covering the topic of Operating System as it covers by example and by showing the reader how it's done in the read world.	2004-03-18
US	50487699	R3SY7NG0YZ1TWN	0321154991	966617861	XForms: XML Powered Web Forms	Books	5	2	3	N	N	Size does not matter	In about 200 pages or so, T. Raman has been able to convey the power of XForms to its readers.  XForms leverage the power of using XML in creating web forms.  It enables the developers to design simple, yet powerful and feature rich, browser-based interfaces for creating XML documents.  It ensures the validity of the XML documents without the use of JavaScript, VBScripts and the entire headache and cumbersome that comes along with scripting languages.  The author in a few chapters, using useful examples and just plain old good writing style, depicts the power of XForms, and shows the reader how the development time of creating a feature-rich web site can be dramatically reduced using this new technology.  Website developers, technology managers and software architects would be able to realize the benefit of using XForms, and determine by reading this book how XForms can save their website project time and money.  <br />This book is divided into three parts:<BR> Introduction - Gives the reader the 20-mile high overview of XForms and the various XML standards that it uses such as XML Schema, DOM2, Namespaces, XML Events and XPath.  <BR> Components - Talks about the various components that make up the XForms architecture.  <BR> Emerging Areas - Talks about the connection between XForms and other emerging Web-Services technologies.  <br />If you were familiar with Struts, it would be very easy for you to learn XForms as it follows the same Model-View-Controller (MVC) design pattern.  XForms consists of mainly three parts:  <BR>The \\"data\\" part of XForms is for any and all nonrepresentational aspects of Web applications.  It is used for user data input, and for validation of that input.  The metadata is also presented at this layer, which is necessary to communicate the user input with the Web Server.  <br />The \\"UI\\" part of XForms defines a vocabulary that consists of abstract controls and aggregation constructs used to create feature-rich UI's.  There is an abstraction layer built-in that allows the applications to be deployed on many different devices and platforms<br />The \\"submit\\" part of XForms allows the developer to specify how and what pieces of data need and can be passed to the Web Server.  It also acts as the controller of the data in that it specifies the actions to be taken once a response have been received from the server.<br />The author then goes into detail talking about the various components that make up XForms.  The MVC design pattern is broken down even more and the details of each component (properties of XForms, the UI to back-end bindings, XForms events, etc) are further discussed and examples are given to convey each topic better.  <BR>Chapter 4 puts the true power of XForms in perspective for the reader.  It talks about a multi-stage UI Wizard and it shows thru an extensive example how it can be developed via XForms.  The same application would take at least a couple of weeks to develop with Struts and JSP/Servlets.  The author in a couple of pages, implements this example and shows the reader how much simpler and faster it is to develop with XForms.  The author concludes his remarks on XForms with talking about the XForms processing model.  The processing model defines various XForms specific events that can be raised, and talks about how and when these events take place.  There are a total of 4 events that occur in XForms: Initialization, Interaction, Notification and Errors events.  Each of these events is described in detail in chap 8 and examples are given so the reader can grasp the topic faster.  <BR>The last part of this book, the author talks about how XForms fits into the Web Services world, and more generally, with other XML technologies and standards such as SOAP, XHTML 2.0 and CSS.  <BR>For a book that would be considered an easy and a quick read, it sure has lots of information packed into it.  In one weekend, you can become familiar enough with XForms that you would be comfortable inwriting a Web application using it.  I recommend this book to any developer involved in Web development.	2004-03-04
US	50487699	R1SHV5R9F24O6V	0321180607	951886131	XQuery from the Experts: A Guide to the W3C XML Query Language	Books	5	3	7	N	N	Very informative set of essays	Simply good.  A collection of essays written by so many well-known names in the industry covering various aspects of the XQuery language from a \\"A Guided Tour\\" to \\"Introduction to Formal Semantics\\".  A book that would be very useful for people with XSLT background, and need more power to do their job.  A book that closes the between Relational Databases and XML.<br />A good number of authors and innovators contributed materials to this book: <BR>- Don Chamberlin (an editor of the XML Query Use Cases, XQuery 1.0, XML Path Language 2.0 working drafts), <BR>- Denise Draper (one of the editors of XQuery 1.0 Formal Semantics), <BR>- Mary Fernandez (one of the editors of the working drafts of XQuery 1.0, XPath 2.0 Data Model, XML Path Language and XQuery 1.0 Formal Semantics), <BR>- Howard Katz (editor of this book)<BR>- Michael Kay (an editor of the XSLT, XSLT 2.0 and XQuery Serialization and XML Path Language 2.0 working drafts)<BR>- Jonathan Robie (an editor of XQuery 1.0, XML Query Requirements, XML Syntax for XQuery 1.0 and XPath 2.0 working drafts)<BR>- Michael Rys (an editor of the XQuery Formal Semantics, XML Syntax for XQuery, XML Query Requirements, XML Query and the XPath Full-Text Requirements working drafts)<BR>- Jerome Simeon (an editor of XQuery 1.0, XPath 2.0 and the XQuery Formal Semantics working drafts)<BR>- Jim Tivy (System architect of the ODMC 1.0 SQL Engine for Microsoft)<BR>- Philip Walder (an editor of the XQuery, XPath Formal Semantics and the XML Schema working drafts)<br />Even though that some of the chapter in this book will benefit an expert programmer, with a solid background in XML, there are more than enough chapter that will benefit the beginner and one's who are no really familiar with XPath, XQuery and XSLT.  The book starts by going over the basics of the XQuery language.  The Guided Tour is simply a refresher, and introduces the reader to XQuery and its syntax/semantics.  It talks about the differences between XPath and XQuery for example, and the benefits of XQuery over XPath.  Small code sections are used to convey to the read the difference of one technology versus the other.  XPath and XQuery get a lot of attention in this book as there are lots of similarities between the two as far as syntax is concerned and plenty of difference as far as its capabilities with XPath.<BR>The author[s] dedicate the second chapter to the principles behind the design decisions of the XQuery language.  Don Chamberlin, the author of this chapter, write the following mission statement for XQuery:<BR>\\"The purpose of the new query language was to provide a flexability to extract information from real and virtual XML documents.\\"<BR>It is very refreshing to see the committee for creating XML actually went to the process of defining requirements, design definitions and the rest of the formal specification realization before they actually \\"wrote\\" the language.  The message of formalism is very clear throughout the book.  At each stage of design for this new language, proper documents have been generated (Use Case doc, Requirements doc, etc) that portray a good process.  The section on formal semantics adds the following:<BR>\\"After the Java programming language was released, several formal semantics of the language were written.  Some of these semantics revealed errors in the type system, which in turn could lead to security holes in browsers that run Java programs. ...\\"<br />XQuery looks very similar to XPath, and this book spends a couple of chapters (a little of chapter 2, and most of chapter 3) to talk about the similarities, differences and influences of one language over the other.  The new releases of XSTL, XPath and XQuery 1.0 look very similar since these groups collaborated with each other throughout the process of development.  If you don't know anything about XPath or XSLT, and want to know how they differ and hoe they have evolved in the recent years, chapter 3, by Michael Kay, is what you need to read - or may even start with before you read the other chapters in this book.  Chapter 3 starts off very easy, but it goes into more advanced topics such as optimization techniques used with XQuery - specially the one's that have been used before with XSLT and XPath for the same purpose.  <BR>One of the most interesting chapters in this book is chapter 5 on Formal Semantics.  It is rare and rather refreshing to see a language being broken up like that and it's predicate logic and semantics be given in such detail.  You can skip this chapter all together, but I suggest otherwise.  Even if it is to realize how language processing and semantics of a language work.  I would love to see such topic for C++ or JAVA...  This chapter is good for anyone interested in optimization techniques and wishes to learn more about the details and correctness of the XQuery language.  <BR>Applications of XQuery at they apply to Databases and how it can be integrated into databases are covered in part 4.<BR>XQuery had the capability to navigate, select, combine, transform, sort and aggregate XML data - thus making the integration of XQuery with the backend database very powerful and rather simple.  XML data, and how it can be integrated into the database with the help of XQuery is covered in detail and two techniques are laid out: the LOB (large object) representation where the entire XML data is saved as a large object in the database, and the composed representation where each XML element is stored individually.  <BR>Even though XQuery is fairly a new language, the authors in this book go to great length depicting the formalism, the correctness, the stability and flexibility of the XQuery language.  The chapters that cover Database integration with XML data clearly convey the power of this language, and thought process that went behind designing such stable and powerful language.	2004-02-23
US	50487699	R1ZGXGE8NFZ4G4	0131411551	606057510	Unix Network Programming, Volume 1: The Sockets Networking API (3rd Edition)	Books	5	74	74	N	N	Continuing the work of a legend in the field of CS	It would be difficult to put value on a book that has been a classic text and a reference in academia and in the real world in the context of Network Programming for over a decade.  Richard Stevens published the ever-popular Unix Network Programming [UNP] back in 1990, followed the second edition in 1998.  With a dedication to the memory of R. Stevens, the UNP book found itself two new authors, Bill Fenner and Andrew M. Rudoff, who would write the third edition of this book.  The third edition has many updates, a new look and feel and many of new chapters that cover the topics more applicable these days.  In my opinion, it is still the most valuable and profound text in the context of Network Programming.  <br />For those of us who have the first two editions of this book, the third edition has the following changes in effect:<BR> IPv6 updates.  In the second version of the book, IPv6 was merely a draft and the sections covering IPv6 has been updated to take these changes into effect.<br /> POSIX updates.  The functions/APIs and examples have been updated to reflect the changes to the latest version of the POSIX specification (1003.1-2001)<BR> SCTP coverage.  3 new chapters that cover this new reliable, message-based transport protocol have been added.<BR> Key Management Sockets coverage.  Network security and its applicability and use with IPsec.  <BR> Updated Operating Systems and machines that are used to run the examples in the book.<BR> Some topics such as Transaction TCP and X/Open Transport Interface have been dropped.<br />Many topics and sections have been updated with the authors' comments.  These comments even though simple for someone new to the profession, are extremely useful as they are like hints and tips from one developer to the next to help you out in your next programming assignment.  <br />If this is the only edition of the book that you are reading, you are in for a treat.  Topics in Network Programming are covered in detail and using concrete programming examples that all of us can relate to - all Unix, but what else is there?!  All kidding aside, the topics are covered well enough that they are useful information under any Operating System.  The concepts don't change; sockets are sockets under any Operating System.  The function call is different, but one needs to go thru the same steps under any environment.  <br />Being the most popular networking protocol, TCP/IP is covered in Part I of the book.  One needs to have prior understanding of the TCP/IP protocol and the OSI model, however.  If this is the first time you are looking at the programming aspects of networking protocols, Part I of this book will cover the basics.  It starts you off with a couple of simple examples such as daytime client and a daytime server and it builds on that as the reader reads along.  TCP, UDP and SCTP (Stream Control Transmission Protocol) are covered in brief in Part I, and basic concepts such as the three-way handshake of TCP and the four-way handshake of SCTP are depicted.  <br />Part II of the book covers sockets and socket programming.  Topics such as the socket Address Structure in IPv4 and IPv6 for TCP, UDP and SCTP are covered and examples (the same daytime client/server) are given to convey the point to the reader.  It is important to mention here that all the topics and concepts are depicted for the three transport protocols: TCP, UDP and SCTP.  Every single socket API under the Unix programming environment is covered and examples are given for each function call to show the reader how the function can be utilized.  An entire chapter has been dedicated to Socket Options and how they are used/can be used for best results.  Hints are given throughout the chapter to tell the user about the pitfalls and best practices of each option. <br />After the basics have been covered, various I/O models are depicted in detail and examples are shown to convey the pro's and con's of each I/O model.  The five I/O models used thru the book and available under the Unix environment are:<BR> Blocking I/O<BR> Non-blocking I/O<BR> I/O Multiplexing (using select and poll)<BR> Signal driven I/O<BR> Asynchronous I/O<br />SCTP - Stream Control Transmission Protocol, a new IEFT standard are covered in later chapters of 9 and 10 and again in chapter 23.  The two interface models of SCTP (one-to-one and one-to-many) are covered in detail, and their differences with TCP are also explained in full.  The client/server example that has been used throughout the book is ported to use the new SCTP protocol.  The authors then go into great detail explaining the problems that SCTP solves over TCP and where and how it would be useful to use SCTP.  <br />Advanced topics such as IPv4 and IPv6 portability, Unix Domain Protocols, Multicasting and advanced Socket programming for UDP, TCP and SCTP cover the rest of the chapters in this book.  <BR>Various options for interoperability between IPv4 and IPv6 start off the last section of the book.  A chapter on Advanced I/O functions brings the reader a new perspective of how complicated Network Programming can become.  Non-blocking I/O, befits and examples are covered in chapter 16.  The topics on Multicasting, and adding reliability to UDP are probably my favorite chapters in this book.  The Time Server that has been used throughout the book is re-coded to become a multicast application.  Some issues that arise when designing multicast applications such as multicast on a WAN are also discussed.  <BR>The third edition of the UNP book is as good as ever.  The updates truly reflect solutions to today's challenges in Network Programming.  Bill Fenner and Andrew Rudoff did an amazing job continuing the work a true legend in the field of Computer Science.	2004-02-06
US	50487699	R2LTR9QALSTPK2	0201799405	996159849	Code Reading: The Open Source Perspective (v. 1)	Books	5	14	17	N	N	Valuable resource of Information and good practices	A valuable resource for best practices, do's and don'ts, what works and why, what you should do in various situations of project, code, and architecture evaluation, and everything in between.  In one phrase, this book depicts Software Engineering's best practices for the real world.  No heavy-duty processes to follow, no reading of Software Engineering text books that are over a 1000+ pages.  More importantly, everything in this book is REAL.  References are given to open source projects where the author took the examples from, and the CD-Rom includes the complete code examples given in the text.   <br />The author starts off by giving a background on the most popular programming languages used in the open-source community such as C/C++ and Java.  Some scripting languages such as a PHP and Perl are also covered, but the main focus of the book is on C and C++.  Data types, data structures and control flow are covered respectively and various best practiced of \\"what to-do\\" is given for each topic.  These topics are somewhat basic, and if you are an advanced programmer, you can read thru these chapters in an hour or so.  Even though these chapters are basic, they contain valuable to-do's and best practices that everyone of us will surly benefit from.  They style of the book and its structure is nothing like I have seen before and it takes a couple of chapter to get used to it.  <br />Chapter 4 is one of my favorite chapters in this book.  It talks about C Data Structures.  Towards the end of the chapter, the author talks about Graphs and Trees.  These two rather complex topics (books have been written on these two topics) are covered so well that with about 20 pages, the reader can get a very good understanding of the topics at hand.  Concrete examples from various open-source projects are used again to get the point across, and the source code that is on the CD-Rom is reusable with little effort.<br />The fun begins with chapter 5, Advanced Control Flow.  Recursion, exception handling, parallel programming and non-local jumps are the main topics covered in this section.  Again, the sample codes really help the reader to understand the topic better, and they also can be refereed to in your next project - something I found very beneficial.  Another interesting thing about this chapter is the part that compares the different thread implementation in various languages and platforms - Java, Win32 and POSIX.  Example from each implementation is given to show the reader the difference in practices and to get the point across more clearly. <br />If you have ever been bored to death by reading books on Software Engineering and Software Processes and just wanted to be able to have a very light and proven process to help you out with your next project, then Chapter 6 - Tackling Large Projects, is for you.  The author starts the chapter by going over some of the design and implementation techniques used widely in large projects such as:<BR> The need for a software process<BR> Complex Architecture<BR> The need to support multiple platforms<BR> The use of OO techniques<BR> Operator overloading techniques when appropriate<BR> The need for Libraries, Components and Processes<BR> The need for custom languages and tools<BR> The use of pre-processing for portability and other reasons<br />Some or all of these methods are needed in large software projects, and author goes into detail in chapter 6 to cover how these tasks can be accomplished efficiently and proactively throughout the project life cycle.  The author starts by going over Project Organization such as directory structure and source tree organization to the build process to revision control for future releases and end the chapter with a topic on testing of software applications.<br />The next two chapters, Coding Standards and Documentation are simply priceless.  In about 40 or so pages, the author is able to cram over twenty years of best practices in coding standards and documentation techniques.  I have never read a book that covered these two topics so well.  If you are a project lead, you can simply take these two chapters and use them in your next project because you will not find anything better elsewhere.  <br />The biggest and the most imperative chapter in this book is Chapter 9, Architecture.  Various architectural patterns are covered.  Each pattern includes a list of projects in the open-source community where it was applied and was proven successful.  The author then goes into various Control Models that are used in the industry such as:<BR> Event Driven Systems<BR> System Manager<BR> State Transition<BR>And examples of each of these Control Models along with code samples are given.  Various packaging methods and schemes such as namespaces, modules, objects, generic programming, Abstract Data Types and libraries are also depicted in this chapter.  Chapter 9 is the longest chapter in this book, but also the most informative one.  <br />D. Spinellis did a great job putting this book together.  This book is packed with examples, best practices and information that are useful to developers, project leads and managers.  Now you can have all the experience of the open-source community, the people that developed Linux, Apache and other popular software applications, at the tip of your finger.	2004-01-21
US	50487699	RWX794UWYOM1A	0321193628	851281583	Concepts of Programming Languages, Sixth Edition	Books	5	29	39	N	N	Great for students, essential for professionals	Concepts of Programming Languages by Robert W. Sebesta, Sixth edition is truly a well-written book.  Perhaps one of the best books written on this topic.  Sebesta has done an exceptional job conveying the topic to the reader, making a complex topic both easy to read and understand.   This textbook is good for any college student or professional trying to get a feel of how the most popular programming languages have evolved in the past 4 decades, and what sets these languages apart.  Topics in this book range from Zuse's Plankalkul (the first programming language) to how Exception Handling is done in Java and Logic Programming and everything in between.  Interviews with some of the pioneers of our time such as James Gosling (the creator of Java) and Bjarne Stroustrup (the designer of C++), and side \\"History Notes\\" represent some of the \\"fun\\" readings the author has added to this book.  Each chapter ends with a brief but concise summary followed by problem sets that assess the important topics covered in the chapter.  <br />Even though this book is targeted for a junior-level programming course, some of the topics are well worth the reading for an advanced programmer or a graduate student.  The author starts by giving the reasons behind why such topic needs to be studied:<br /> To increase capacity to express ideas - the depth at which we can program, just like the way we think, is highly influenced by the expressive power of the language in which we communicate our thoughts.<BR> Improved background for choosing appropriate language - if you know more about programming languages, you have a better idea what to choose when development time comes.<BR> Increased Ability to learn new languages - continuous learning in the field of software engineering is very much essential.  If one knows the concepts of one programming language, applying those concepts to other language to learn or understand become much simpler and easier.  <BR> Better understanding of the significance of implementation - Someone who knows the implementation details of that language can only fix some programming bugs.  <BR> Overall advancement of computing - For better decisions to be made going forward with computing and software development, one needs to learn from some of the mistakes that gotten us where we are.  Things to do or not to do in this relatively new science.  <BR>The author starts by giving a very descriptive background on programming languages, starting from Zuse's Plankalkul, the first programming language.  Zuse's defined the Plankalkul and wrote many algorithms in the language for a variety of problems.  Even thought it was never implemented, Plankalkul paved the way for other programming languages that would follow it.  Fortran, LISP, ALGOL 60, COBOL, BASIC and other high-level programming languages would follow over the years and evolve.  The author gives the history behind each language, and goes in to a detail description of how each language evolved over the years.  Even though chapter 2 gives the background behind most programming languages, the book only covers the most popular and widely used programming languages thereafter, mainly Fortran, C/C++, Ada and Java.<br />If your goal is not to teach or learn the details of compilers and/or compiler design, chapter 3 and 4 are defiantly for you.  There are many books written on compilers, but Sebesta in one chapter covers the main topics of syntax and semantics and in another covers lexical and syntax analysis.  Lexical analysis talks about small-scale language constructs, such as names and numeric literals.  Syntax analysis deals with the large-scale constructs, such as expressions, statements, and program units.  In less than a hundred pages of text, the author explains the background, theory and implementation of syntax and lexical representation and analysis.  It wets the reader's appetite enough that if the reader is interested, he or she can follow the course by taking a compiler design course or read the popular Compilers book by A. V. Aho for example.  <br />The author proceeds to talk about naming, binding, type checking and scopes.  Various constructs from different programming languages make up this section, with an emphasis on storage binding and variable lifetime.  Various storage types (such as static, stack-dynamic variables and heap-dynamic variables) and their corresponding lifetimes along with their implementation in each language are also covered.<br />The author then goes into the \\"newer\\" topics such as Abstract Data Types (ADT's), Object Oriented Programming, Concurrency and Exception Handling.  The author firsts discussed the concept of ADT's and conveys to the reader the benefits of abstraction and encapsulation thru examples programs in Ada, C++, Java and C#.  The author in its closing remarks adds:<br />\\"The two primary features of abstract data types are the packaging of data objects with their associated operations and information hiding.\\"<br />ADT sets up the stage for what the author talks about next: Object-Oriented Programming.  As with the other chapters, the author starts off by touching on the design issues for Object-Oriented languages.  The author then goes off and says:<BR> <BR>\\"In this purest model of object-oriented computation, all types are classes.  There is no distinction between predefined and user-defines classes\\"<br />The important topics of various object-oriented languages such as inheritance, multiple inheritance, type checking and polymorphism, allocation and deallocation of objects, dynamic and static binding are covered and their corresponding implementations are discussed in detail for each object-oriented language such as in C++.    <br />Robert W. Sebesta has done an exceptional job depicting the topic of programming languages.  The background, the history, the design issues behind each decision, the implementation of each language, the evaluation of features between the popular languages, the problem sets at the end of the chapter and last but not least, the interviews with pioneers in the computer science world, make Concepts of Programming Languages, sixth edition a great book.	2004-01-13
US	50487699	R1S7D037FTVLTO	0321125215	454381651	Domain-Driven Design: Tackling Complexity in the Heart of Software	Books	5	120	129	N	N	Re-introduces a new way to think about software design	If you have even been involved in a software project (a) as a developer and did not know what the end product is going to be used for or how it will be used or (b) as an architect who spent countless hours with your stakeholders and domain experts trying to figure out how to go about architecting your application, then you should read this book.  Read it again after you have read it for the first time.  This book is packed with pointers, information, tips, how-tos, \\"down to earth\\" practical samples, and even conversational examples that one could have while gathering requirements.  Evans in his book fills a wide gap that we all tend to come across while designing software applications.<br />There are many software engineering processes out there, and each one tries to tackle the complexities of designing software applications for a given domain in its own way.  Evans recognizes the tools and the processes that are popular in the industry, UML, Agile, and focuses on some aspects of the software engineering process that we tend to miss.  He starts the book by talking about the importance of creating and having a Ubiquitous Language.  There is a similar concept in the RUP, but not emphasizes as much - or at all.  Evans goes into a great detail on why, from the inception of a project, it is important to have a common language and gives many pointers on what makes up the Ubiquitous Language for each project:<br />\\"Use the model as the backbone of a language.  Commit the team to exercising that language relentlessly within the team and the in the code.  Use the same language in diagrams, writing, and especially speech.\\"<br />Parts II-IV of the book put domain-driven design in perspective, and show the reader thru examples and patterns, architectural patterns, design patterns and process patterns, the importance of having a consistent model that maps to the domain and how to go about achieving such model.  In an essence, \\"Model-Driven Design discards the dichotomy of analysis model and design to search out a single model that serves both purposes\\".<br />Part II of the book, introduces the building blocks of a Model-Driven Design.  This section, as with the others, takes popular patterns from the Gamma, Flower, or others and applies them to the topic at hand - Model-Driven Design.  In that aspect, the reader can easily follow the text and relate to topic at hand.  Evans uses the ever-popular Model-View-Controller (MVC) design pattern to get things going in part II.  He then goes off to explain why the layered architecture approach is an important aspect of a Domain-Driven Design and how it would makes things simpler:<br />\\"[Layered Architecture] allows a model to evolve to be rich enough and clear enough to capture essential business knowledge and put it to work.\\"<br />The author then goes into great detail in explaining the elements that express a model:<BR>1) Entities:  An object that is tracked thru different states or even across different implementations.<BR>2) Value Objects: An attribute that describes the state of something else.  <BR>3) Services:  Aspects of domain that are expressed as actions or operations, rather than objects.  <BR>4) Packages: Organize the objects and services.  <br />What do you want to do after you have designed such elements?  The creation and life cycle management of objects are discussed next in this book.  Three patterns, mostly from the Gamma book, are used to manage the life cycle of objects:<BR>1) Aggregates.<BR>2) Factories.<BR>3) Repositories.<br />Aggregates represent the hierarchy of objects or services and their interactions.  Factories and Repositories operate of Aggregates and encapsulate the complexity of specific life cycle transitions.  <br />Part III of the book talks about the things developers and architects need to do to achieve a Supple Design.  Refactoring over and over represents the topic in this section:<br /> \\"Each refinement of code and model gives developers a clearer view\\"<br />The author talks about a breakthrough point during the design that the \\"designers see the light\\" and both the domain experts and the designers, after many iterations, have finally come to this higher level of understanding of the domain and the value of refactoring exponentially increases after that.  <br />Part IV of this book talks about a very important topic that we all have struggled with one time or another: the ability of the model and the modeling process to scale up to very complicated domains.  It is great that we can model a small domain, but one goes about modeling an enterprise, which is most likely, too complex to model as a single unit?  Low-coupling and high cohesion still applies here, but the goal is to not loose anything during the integration process. The author goes in to a great detail in this part to emphasize that even in large circumstances such as modeling an enterprise, every decision must have a direct impact on system development.  Three different themes are covered in this section in order to assist with modeling of large units:<BR>1) Context: the model has to be logically consistent throughout, without contradictory or overlapping definitions.  For this theme, the author introduces the concept of a Bonded Context- a way that relationship to other context are defined a overlapping is then avoided.<BR>2) Distillation: Reducing the clutter and focusing attention appropriately.  <BR>3) Large-scale Structure.  The concept of Responsibility layers are introduced <br />In summary, Evans did a great job in writing this book, and filling it with useful ways of designing and architecting software applications that target a domain, which in most cases we do not know much about.	2003-12-25
US	50487699	R2JQ6PO295ZYP5	032119442X	559880628	MDA Explained: The Model Driven Architecture: Practice and Promise	Books	5	6	8	N	N	MDA is here is to stay	There have been many talks about MDA, but none as \\"complete\\" as this book.  Granted that MDA is still under development and who knows what will actually happen to it when it is actually released, the authors of this book do an extraordinary job explaining what MDA is at its current stage and what areas might still change for the better before its final release.  <BR>MDA is here to stay.  There are many people that are very skeptical about the future of MDA, but the authors thru show and tell, explain why MDA is very much needed by the community and why it is here to stay for a very long time.  The book starts by touching on some of the current problems that the software development process is facing these days:<BR> Productivity problem:  Writing code is being productive, and models that do not relate to anything with the code and are just stick figures on papers don't really mean much<BR> Portability Problem:  The need to port applications from one platform to another, or from one technology to another<BR> Interoperability Problem:  The systems need to interoperate and integrate together much more smoothly than they do today<BR> Maintenance and Documentation Problem:  Documents don't really mean much if they are not representative of the current system and can not be used to figure out what the system does.  <br />It is very difficult; as you may have had the pleasure of finding out the hard way, to actually implement true round trip engineering.  It is a great concept on paper, but once you start the process of coding who has the time to go back and update the model?  Update the use-cases and propagate the changes all the way down stream to the test cases?  Specially if your project is under the gun and is already behind the schedule.  The truth of the matter is that until today, modeling has been a great concept to kick things off, but many managers, project leads, etc... do not see the value of modeling and how it can improve their software.  MDA is the answer to these questions...  It's what we like to have if we had it all...  It is a promise of something grand and it's being presented in this book as such.  This book is the blue print of where things in the software development process will be 3-5 years from now.  <br />The author then goes into the details of the MDA framework and breaks that up to 4 parts:<BR> The Model<BR> The language in which the model is written in<BR> The transformation definition which describes how the model in one language can be transformed into another<BR> Transformation tool which performs the transformation using a specific transformation definition<br />Each part of the MDA framework is then broken up into its sub-parts and each are explained.  The model, which is what we all are familiar with, is actually broken up to three parts in MDA:<br /> The Platform Independent Model - PIM<BR> The Platform Specific Model - PSM<BR> The Code<br />The bulk of what MDA is in the transformation tools that transform one model to the other.  The author spends a great deal of the book explaining what these transformation tools could look like, and it actually gives three examples of such tools in this book:<BR> Transformation tool to transform PIM to PSM for a relational database<BR> Transformation tool to transform PIM to PSM for EJB's<BR> Transformation tool to transform PIM to PSM for a client front-end written in JSP<BR>Each of these transformation tools is explained in great detail, and the depicted such that it is very easy for reader to follow the path of how the transformation is/should be done.  The authors then talks about the transformation tools that take each PSM and transform it to Code.  It is at every step of the way, from creating the PIM to Code, the authors spend a great deal of time explaining how MDA is introducing a new way of doing things better, faster and more efficiently. <BR>Metamodels and metalanguages are covered in chapter 8.  A Model is written isa Language, which is defined by a Metamodel, which is written in a Metalanguage.  MDA follows the same pattern.  The metalanguage in which MDA is written is called the MOF.  The metamodel for the MDA are written in MOF, and the modeling itself is done via UML.  All the standards that are covered under OMG are covered in chapter 11, and is very interesting to see how pieces fit together, and how the \\"stack\\" is being built.  <BR>All and all, Anneke Kleppe, et. al. did an extraordinary job in putting this book together.  MDA is a buzz word that we have been here for sometime now, and it is great to finally have a book such as MDA Explained that clarifies the concepts and sheds some light on what's coming and what to expect.	2003-12-18
US	50487699	RC5H024F3RHZ5	0201775948	319379482	Beyond Software Architecture: Creating and Sustaining Winning Solutions	Books	5	31	33	N	N	Depicts the Development Process in its fullness	There must be hundreds of books on the software developmental process, but I have yet to see a book that covers the business, technical marketing, sales cycle, deployment cycle, release cycle, licensing, installation, upgrade cycle, and everything in the middle all in one compact book.  This book TRULY covers the life of a software application and everyone involved in it.  <br />For us techies, this book starts with what we are familiar with:  \\"Why software architecture matters?\\"  The author starts with a general overview of the topic, but it goes much further into the non-technical details software architecture, such as the Social Structure aspect:<br />\\"A good architecture works for the team that created it.  It leverages strengths and can, at times, minimize their weaknesses. ... Once created, the architecture in turn exhibits a strong influence on the team.  No matter what language you've chosen, you have to mold the development team around it because it affects such as things as your hiring and training policies.\\"<br />New comers to the architect world don't really think about such aspects, or at least it's not really high on priority on many people's lists.  The author puts such things right next to profitability, stability of the architecture, and defining the technical boundaries.  Granted that Social Structure aspect of the architecture is as important as the others, you can't really find many books out there that treat it as such.  Personal experience teaches us that, but there are cases, many cases, that one doesn't have the luxury of \\"trial and error\\".  The author takes great pride in his experience and has written this book like a personal assistance to a newbie to the job, and to the expert architect with topics such as branding issues, licensing affects on the overall architecture and more... <br />Tarchitecture and Markitecture are two words/concepts that are used frequently throughout this book.  The author starts with the inception of software applications and explains the important rule that Market Architecture (Markitecture) and Product Management have in the overall picture of a software lifecycle.  Why Business plan is important and how it should be written, how to release version 1.0 and subsequent versions, how customer input and interaction with the markitects play the most important rule in the subsequent releases of your software, and other such important questions are covered in chapters 2 and 3.  <BR>The chapter Software License and Licensing models is probably one of the most valuable chapter (chapter 4) in the entire book.  The author describes the concept of licensing and how it fits into the overall architecture and how it affects the architecture very elegantly.  Various licensing models and their pros and cons are described:<BR> Time based<BR> Transaction based<BR> OEM bases<BR> Metering style<BR> Hardware based<BR> Services based<BR> Revenue Obtained/Costs saved.<BR>The author explains why it is important to select the right licensing model, and how and why it could have a negative effect on your architecture if the wrong one is chosen.  Various options for choosing a model are then explained such as the Honor System, the homegrown license managers, and the third party tools available.  <br />Another important aspect of software architecture - the-after-development-has-been-done-now-what aspect, is covered throughout the rest of the book.  Deployment, installation, configuration and upgrades are the key topics.  Other topics such as extensions to the current architecture, logging and branding are also covered in detail.  <BR>The chapter on installation is another well-covered chapter that talks about a topic not covered at all or well in other books out there.  Various deployment architectures are covered; Customer site installation, ASP, Managed Service Provider, and Web services models make up the topics for this chapter.  This chapter, just like all the other chapters, relates the topic at hand to the overall system architecture, and why and how it can have an effect on the overall architecture of the system.  <br />Throughout the book, one theme screams out to the reader: \\"How every decision an architect makes affects the rest of the software life cycle, and what the architects need to think about and consider before coming up with their design?\\"  The cycle - software life cycle, and how it is affected by the end user/customer, why it's the job of the market architects and business managers to gather the key points from their customers, what are some of the concerns that are common with any architecture (deployment issues, upgrade concerns, installation difficulties, logging and error reporting, security concerns), and tone of the most important aspect of all: Social aspects and how they have an important affect on the tarchitects, markitects and the overall application.  I think the author says it best in the preface of the book:<br />\\"You need to move beyond software architecture and move toward understanding and embracing the business issues that must be resolved in order to create a winning solution\\"	2003-12-08
US	50487699	R2A9ZRWOW8EH3P	0130609285	330957169	Object-Oriented Defect Management of Software	Books	5	1	1	N	N	Required reading for any software engineer	The need for defect detection in software applications, small to large, has become one the primary concerns of any organization.  The lower the number of defects, as it is perceived, the higher the quality of the software.  H. Younessi in his book, OO Defect Management of Software, answers some of the very questions asked by architects and tech leads regarding defect detection, and defect prevention in software.  The process proposed works with all the popular software engineering processes mainly, the RUP and is \\"compatible\\" with UML.  This book is a must read.  It \\"does\\" software engineering and project management from a brand new perspective: How create a software application with as little defect as possible?  How can a group or an organization tailor their process so that the number defects injected is minimized, and the number of defects found is maximized?<br />Defect detection and management is a topic that you don't hear too much about or consider during a software development process.  Once the code has been written, and then you start figuring out what went wrong, what was done incorrectly, and what needs to be redone.  Younessi in his book outlines extensions to popular development processes, and puts defects in center stage (where it should be) and almost \\"forces\\" the developers, architects, tech leads, etc to think about the quality of the software that they are creating.  This extension is added to every stage of the process, from inception all the way thru testing.  Assuring for example that your tests are effective and you are not injecting more defects into the application while you are testing.  The author thru out the book is showing how one can balance all the elements of software engineering: People, Methodology and Technology with a hint of defect management with which the application would be of a higher quality.  <br />The author sets the stage for the book in the first two chapters.  From chapter 3 to the end of the book, the author delvesinto the phases of the software engineering process (inception, requirements, design, development, test and deployment), and explains how each of these stages can be tailored with defect detection and management in mind.  Let me remind you that in the normal software engineering processes or texts, defect detection or defect prevention is not really considered.  All the processes talk about quality software, but not much time is spent on what that really means.  Normally, you need to figure out how you can put together the techniques you learned about creating quality software and the techniques you learned about a development process.  This book leaves that guessing part out, and actually tells you what YOU need to do at EVERY stage of a software development process to ensure that 1) defects are detected as early as possible and 2) defects are not injected in to the process as much as possible.  This entire process is not pure science by any means.  There is no equation for it or anything, but the author gets pretty close in creating an almost \\"bullet proof\\" process where if followed, quality software is assured.	2003-12-02
US	50487699	R1RZS4ASYIIUM8	0321154959	687800358	Software Architecture in Practice (2nd Edition)	Books	5	34	40	N	N	A Bible for Software Architects	Being a Software Architect, I can certainly appreciate the work that the authors of this book (L. Bass, P. Clements, R Kazman) have put into this book.  Software Architecture in Practice is probably the best book that I have read on the theory and practice of architecture design and software engineering.  There is no fair way for me to review this book as it is PACKED with useful information from beginning to the very end.  It has a combination of high-level architectural concepts tailored with best software engineering practices.  It is not a complete book on software engineering, but it wasn't meant to be - it's meant to cover a very specific topic in software engineering and it does so extremely well.  It is a text in which the concepts architecting software applications, evaluating architectures thru various methods, and case studies of major leaps in software architecture have been very well described; depicted and well evaluated.  The book is written from an architect's point of view, and it shows how an architect or a group of architects can make or break an organization, and what they need to do in order to be successful.  The authors of this book explain why simply architecting something is not good enough and lots of work needs to be done before and after the architectural phase to ensure the quality and the success of the project.  This aspect of the book is simply priceless. <br />The author start by describing software architecture as:<br />\\"The Software Architecture of a program or computing system is the structure or structures of the system, which compromise software elements, the externally visible properties of those elements, and the relationships between them.\\"<br />Throughout the book, the author used this definition to describe various aspects of architecture.  One of the methods/techniques that the author uses is called the Architecture Business Cycle (ABC).  ABC is method of realizing the \\"things\\" that influence the architect and in-turn thearchitecture - known as the circle of influences.  This concept, ABC, is used for all the case studies mentioned in this book:<BR> <BR> A case study on a system that have extreme safety requirements - the Air traffic control.<BR> A case study on a system with high level of distribution of its subsystems - A flight simulator <BR> A case study in which it was essential for the organization to be able to share documents instantaneously.<BR> A case study on an organization where one architecture lead to a product line of applications<BR> A case study on the need to standardization of architectural approaches across organizations and the community - J2EE and the EJB.<br />For each case study, the authors depict its ABC and give the reader the reason, business reason, that this project got started to begin with.  The reader then walks thru a series of decision-making steps that led to the architecture that was finally chosen.  The drivers of the project, the business reason, the architect[s], and the organization are all linked and the authors go into a GREAT DETAIL on how this link can influence the final design.  <br />Architecture Tradeoff Analysis Method or ATAM is a new topic that is added to the second edition of the book.  ATAM is a structured method of evaluating architectures.  <br />\\"It results in a list of risks that the architecture will not meet its business goals\\"  <br />The authors start by describing the roles and responsibilities of people involved in ATAM, and the output artifacts that ATAM will produce when completed:<br /> A Concise presentation of the Architecture<BR> Articulation of the business goals<BR> Quality requirements in terms of collection of scenarios<BR> Mapping of architectural decisions to quality requirements<BR> A set of identified sensitivity and tradeoff points<BR> A set of risks and non-risks<BR> A set of risk themes.  <br />The process of ATAM is depicted next in which there are a total of 4 phases:  <br />1) Partnership and preparation: the key project decision makers informally meet to work out the details of the ATAM process.  <BR>2) Evaluation phase - the long evaluation process of the architecture with the same project decision makers as in previous phase<BR>3) Evaluation phase, continued - this time the stakeholders are present<BR>4) Follow up - the stakeholders and the evaluation team meets again to follow up.<br />The process is described very well and examples forms are shown in the book that can be used for your evaluation process.  The great thing about this chapter and how it's written is the way that the ATAM process is presented.  It is almost like a checklist that the architects need to follow.  Very easy to read and follow.  The inputs of every phase are clearly identified, and the description of the output is depicted rather clearly.  The chapter ends with yet another case study that shows the \\"theory\\" just presented.  The authors close the chapters by having the following comments about this book:<BR> ATAM is not an evaluation of Requirements, but only the architecture<BR> ATAM is not a code evaluation<BR> ATAM does not actually involved system testing<BR> ATAM is not a practice instrument, but identifies possible areas of risk within the architecture.  <BR>The ATAM is followed by another very well written topic on CBAM (Cost Benefit Analysis Method).  This chapter is also new in this edition, but I will leave the details of this chapter for the reader.  I like the ATAM method more than the CBAM, because it seems simpler to me.  <BR>All and all, the authors in this book did a fantastic job in writing this book.  This book is packed with useful information for architects, project leads, and even technical managers.	2003-11-25
US	50487699	R2YV6L62UNPMKD	0201699710	502837850	The ACE Programmer's Guide: Practical Design Patterns for Network and Systems Programming	Books	5	27	32	N	N	Great way to learn the ACE Framework	This is probably the most practical book ever written on this topic.  I have read the C++ Network Programming books, and I believe that this Programmer's Guide is even better.  <br />ACE, the ADAPTIVE Communication Environment, has been around since the early 90's and thanks to over 1700 contributors over the past decade or so, it has become a very powerful, reusable, Object Oriented, beautifully engineered, designed, and developed framework that is creeping its way to the hearts of developers, project leads, and managers all around the world and in many industry verticals.  <br />ACE has made one of the hardest things to do as a developer, network programming much simpler, but that's not all.  That's where this book comes into play.  The other books focus on the network programming of ACE, and even though they cover the topic VERY well, they don't convey the other powerful features that ACE has:<BR> ACE Logging Facility<BR> ACE Runtime and configuration facility<BR> ACE (STL like) containers, allocators, etc...<br />Right of the bat, this book covers those details and shows the reader concrete examples and ways to apply these examples in real life.<BR>The author spends the next 4 chapters (6-9) going over the IPC facilities of ACE.  It starts from basic SOCKET programming, to SIGNALS, to the use of TIMERS and it ends with the odds and ends of IPC.  These topics were covered in the C++ network programming books before, but this book, instead of talking about it, SHOWS the reader how things are done.  The Reactor and the Proactor frameworks are covered in chapters 7 and 8.  As the author mentions in chap 7:<BR>The ACE reactor framework was designed to implement a flexible event-handling mechanism is such a way that applications need never write the central, platform-dependent code for their event-handling needs.<BR>Then the author goes into an extensive detail of how this is done, and in its closing remarks, he says the following:<BR>With little ingenuity, your reactor-based application can turn on the foyer light when someone pulls into your driveway or mute the television when the phone rings.<BR>The Proactor framework is covered in full detail in the following chapter.  The author does a great job at telling and showing the differences between the two design patterns and when to use one vs. the other.  When all said and done, the author explains how these two design patterns can make a killer combo.<BR>The book is more like a personal notebook that you would create for yourself in that you write down notes, hints, do's and don'ts and few lines of code at a time telling yourself how you made something to work properly. <br />In Part III, Processes and Threads are covered.  Even though the author has included these chapters after the IPC section, a great deal of detail was spent on showing the reader that these classes are not necessarily related to the IPC set of classes.  The reader can literally read part III of this book, and gain a good understanding of how to use the thread and the process management classes - remind you that these two topics are difficult to grasp and programming is a bit difficult, but the author shows how cleanly these two topics were covered in ACE.  The icing on the cake is the last chapter in Part III: Thread Pools.  Two threading models are covered:<BR> Half-sync/half-async model<BR> Leader/follower model<BR>I will leave the details of these two models to the reader.  <br />Part IV covers the \\"advanced topics\\" such as shared memory, the configuration framework, timers, and the naming service.  Again, for each section an extensive example is given, which makes the topic easy to understand and to follow.  The configuration framework is a very well covered section, as it is something that any of us can benefit from in our next design.	2003-11-21
US	50487699	RTFTDC09VNX9B	0321179366	137500157	The Object Constraint Language: Getting Your Models Ready for MDA (2nd Edition)	Books	5	7	8	N	N	Take your Software Engineering Skills to the next level	This books thru explanations, clear and concrete examples and a concise case study shows the reader how to take your software engineering skills to the next level.  It shows practical uses and examples of the concepts that you leaned while studying Object Oriented concepts in school.  For the Computer Scientists, this book is one smile after another of how some things that you always thought was great in concept have showed up in the real world.  For a book that's less than 300 pages long, it sure compacts lots of information in there.  <br />This was my encounter with the Object Constraint Language, or OCL.  I have been using UML for work for a number of years now, but I never gave OCL a second thought other than a \\"nice-to-have-conpcept-that-makes-your-life-harder-than-its-worth\\" type of technology.  This book was an eye opener.  I am really glad that I took the time to real this book.  <br />The book has three major parts:  <BR>1) User manual<BR>2) Reference Manual<BR>3) Appendices<br />By looking at the TOC, one is not really impressed.  User manual?  Reference Manual?  I thought I am going to be bored to no end while reading this book.  The TOC does not do justice to the book.  The author in chapter 1 introduces MDA and its benefits (Portability, Productivity, Cross-platform interoperability, and easier maintenance and documentation).  The author then introduces the concept of Modeling Maturity Levels (MML), which is very similar to the CMM levels for Software Engineering.  MML has five levels and is used as an indication of, \\"...what role models play in your software development process, and the direction you need to take to improve this process.\\"<br />i) Level 0: No Specification.  Add-hoc development<BR>ii) Level 1: Textual. Specs written in one or more natural language documents<BR>iii) Level 2: Text with Diagrams. Several high-level diagrams are added to explain the over-all architecture<BR>iv) Level 3: Models with Text.  Models with a very specific and well-defined meaning, forms the specification of the software<BR>v) Level 4: Precise Models.  \\"A Model, meaning a consistent and coherent set of texts and/or diagrams with a very specific and well-defined meaning, specifies the software\\" <BR>vi) Level 5: Models only.  There will only be models and that is all.  <br />Level 4, which is where MDA is targeted towards, is enabled only thru the use of a language such as OCL.   I have never heard or seen anything on MML, but I certainly hope that people start using it more b/c it clearly explains an organization's software development process maturity.  <br />In the rest of the chapters of part 1, the author goes thru extensive set of examples showing how to use OCL.  Chapter 2, titled \\"OCL By Example\\" is a case study of what is referred to as a \\"Royal & Loyal\\" application in which there are tons of short, long, beginner, advanced, and everything in the middle types of examples.  <br />One example of a concept that you would love to apply in the real world is the concept of \\"Design by Contract\\" (Chapter 3, page 43).  There are a couple of books written on this topic (Meyer, McKim, etc...), but they all focus on Eiffel.  OCL being language independent abstracts some of the limitations that some of the programming languages have and enables the developer to apply the idea of contracts thru preconditions and post-conditions.  One still has to worry about the \\"under the hood\\" implementation of these concepts, but it is very nice to see that there are tools out there that are heading towards that direction.  The author spends the rest of chapter 3 of the book applying OCL to various aspects of UML such a state charts, class diagrams, activity diagrams, component diagrams and Use-case diagrams.  <br />A somewhat complete and good example of how OCL maps in to a programming language such a Java is shown in Chapter 4.  It's a good reference, but at the beginning of the chapter, the author gives the URL of a web site that is dedicated to providing OCL implementation in various languages ([...]<br />In part 2 of the book, various aspects of OCL such the context of an OCL expression are explained.  The examples that were drawn in part 1 are used in go deeper into the heart of OCL and show the reader what is actually going on.<BR>Chapters 7 thru 9, which are my favorite chapters in this book, are used to explain the elements of OCL.  What makes up OCL?  Data structures, user defined types, predefined types, and built-in operations.  These chapters are truly reference manuals of OCL, but with tables, examples, and very short but sweet explanation of each topic.  Each topic takes one-half or three-quarters of a page and is followed by a couple of examples.  Chapter 9 on data structures that make up OCL (Bag, Set. OrderedSet, and Sequence) is probably the most important chapter of all three, since manipulation of collections is very common in almost any application.  <br />All and all, the author did a great job showing the value and the promise of OCL as a technology that can take software engineering to its next level with the help of MDA.	2003-11-18
US	50487699	R1COOEEM0HSE7E	0131013769	651708143	Parallel and Distributed Programming Using C++	Books	5	18	26	N	N	Covers the topics VERY well	This book covers the MPI (Message Passing Interface) library, the PVM (Parallel Virtual Machine) library, and the MICO (CORBA) library.  If any these libraries were new to you, then this book is would be very beneficial to you.  <br />So many books have been written on PTHREADS, threading, multiprocessing, etc, and yet, this book seems to cover more grounds, teach more concepts, and show you more simple but useful examples that any other one's that I have seen.  The books on PTHREADS cover threading, there are a number of books on multiprocessing, networking (Stevens book comes to mind), but as far as generic multiprocessing, and parallel processing is concerned, this book is the key.  Hughes and Hughes have written another similar book, but that book mainly covered C++ and threading (hence the title of the book).  This book covers other great C++ tools such as the PVM (parallel virtual machine), which to my limited knowledge has not been covered greatly in any other books.<br />The first couple of chapters cover basic Operating System stuff.  I don't know if it's because I have working for a number of years, or not, but the it actually made sense.  We all have read the ever popular Modern Operating Systems book, but that book is somewhat dry.  Maybe I think that say since I HAD to read the book for my class, but that feeling hasn't changed.  This book covered the topics that you NEED to know, if you want to be able to write a program that takes advantage of some of the libraries mentioned above (MPI, PVM, MICO, and PTHREADS).  It talks about the benefits, differences, and ideas behind parallel and distributed programming.  <br />The next two chapters are probably the best chapters I have read on the topics of Multiprocessing and Multithreading respectively.  The chapters are titled \\"Dividing C++ Programs into multiple tasks,\\" and, \\"Dividing C++ Programs into multiple Threads.\\"  <BR>I cannot say enough about how good these two chapters cover the topics.  They startby the definition of both models, and they peel the onion as each chapter moves along.  By the end of the chapter, you have seen examples, different design models for each method, and the pros and cons of each design model.  Following these two chapters, a chapter is dedicated to synchronization and issues that go along with that in multithreaded/multiprocessing applications.  <br />PVM, the Parallel Virtual Machine, is covered in chapter 6.  This chapter must be my favorite chapter in the entire book.  The authors give the following description for PVM:<BR>\\"The PVM represents a collection of networked computers to the developer as a single logical machine with parallel capabilities.\\"<br />The authors goes further and says:<BR>\\"The PVM library is perhaps the easiest way to add parallel programming capabilities to the C++ language.\\"<br />In general, the PVM is broken down into seven categories:<BR>i) Process Management and Control: Routines used to manage and control PVM process<BR>ii) Message Packing and Sending: Routines used to pack messages into a send buffer and send messages from one PVM process to another<BR>iii)  Message Unpacking and Receiving: Routines used to receive messages and unpack the data from the active buffer<BR>iv) Task Signaling:  Routines used to signal and notify PVM processes about the occurrence of an event<BR>v) Message Buffer Management: Routines used to initialize, empty, dispose, and otherwise manage buffers between PVM processes<BR>vi) Information and Utility Functions: Routines used to return information about a PVM process and perform other important tasks<BR>vii) Group Operation: Routines used [in] joining, leaving, and otherwise managing processes in a group.<br />The authors then go in to detail covering the two programming models used commonly with the PVM: SPMD (Single Program Multiple Data), and MPMD (Multiple Program Multiple Data):<br />\\"In the SPMD model, the tasks will execute the same set of instructions but on different pieces of data.  In the MPMD model, each task executes different instructions on different data\\"<br />The topics covered in PVM also apply to the chapter that covered MPI, the Message Passing Interface covered in Chapter 10.  The authors go a step further in this chapter and talk about how some of C++ features such as polymorphism, generic programming and templates, and operator overload can be used in conjunction with the MPI to make programming simpler and more efficient.<br />The authors go into detail in the next few chapters about the Software Engineering aspects of the topics covered.  Modeling aspects are covered first, and then applications and design.  UML is used to show the readers how to represent concurrent and parallel designs.  Flow charts, activity diagrams, class diagrams and state diagrams are used to represent the examples that were covered throughout the book.  <br />A closer look at C++ and Object Orientation covers some advanced topics in the book.  Various C++ class types are used in examples to show the modeling aspect and then the designing aspect of concurrent and parallel programming.  <br />The last chapter of the book uses all the concepts covered in the book to implement a full-blown blackboard application.  The BB is an approach to collaborative problem solving.  The BB is used to record, coordinate, and communicate the efforts of two or more software-based problem solvers.  The authors design and implement the BB using various architectural methodologies covered in the book: using the PVM, Threads, and CORBA.  The examples certainly put everything that were covered in the book in perspective and enable the user to understand and grasp the topic at hand very simply.  <br />C. Hughes and T Hughes picked a very difficult topic to cover and they did one fantastic job at doing so.  The examples are great.  The topics are covered very thoroughly, and yet are very understandable.  Any series C++ programmer, developer,  or architect would benefit lots from this book.	2003-11-11
US	50487699	R191TBGV7N4S64	0130463469	123060330	Core PHP Programming (3rd Edition)	Books	5	13	14	N	N	Great book on PHP	How can you convey the power, the flexibility and the simplicity of a relatively new language without loosing any of your audiences, beginner to advanced, along the way?  <br />I have been a programmer for over 6 years, but have never had the pleasure of doing anything with PHP before I started reading this book.  I must say, I was totally impressed after I had finished reading Leon's book.  The PHP language itself has grown tremendously over the past 8 years or so, and I can certainly see why it is so appealing to users of all levels.  The author of the book, Core PHP Programming, does an amazing job explaining the nuance of PHP that any level READER can understand the topic and does whatever it is that he or she is after - which would be designing a dynamic web site in this case.<br />Leon starts the book with the paraphrase \\"...answer is that PHP is better\\" and goes on to explain why that is the case.  His answers would compel any PHP user or potential users:<br />1) PHP is free<BR>2) PHP runs on UNIX, Windows, and Mac OS X<BR>3) PHP is modifiable<BR>4) PHP was written for Web Page creation<BR>5) Support for PHP is free and readily available<BR>6) PHP is popular<BR>7) Programming skills developed in other structured languages can be applied to PHP<br />By the end of page 11 (5 pages into chapter 1) the reader is hooked and wants to read on to find out what all Leon is talking about.  All the key phrases are there: free, extendible, lots of supports, and ease of use.  <BR>By the end of Chapter 7 or page 160, you are ready to rock.  By now, you know what PHP is all about and have learned its syntax, features, and have even looked (or hopefully written) some code.  <BR>Dynamic Function Calls ends chapter 4.  This section CLEARLY shows to any programmer how powerful PHP really is and how easy it would be for anyone to utilize that power.  Dynamic Function Call is very difficult to implement in Java (I don't know of any way to do in C++ actually - specially in one line of code).  In one line of code PHP is able to accomplish this task.  Very powerful stuff...<BR>I was personally very impressed with the OO features of the language, which was depicted very well in chapter 6.  I also need to say that Leon's introduction to Objects and Classes are very easy to understand for users new to the topic.<br />For the next few hundred pages, in Part II of the book - Functional Reference, various functions that PHP supports are shown and each one is explained in a great detail.  Most of the functions have also been followed by an example that shows the usage each function just described.  These chapters are very good reference even for the advanced users as PHP has grown so much that keeping track and memorizing of all the functions would be nearly impossible.<BR>Leon ends the book with a section called Software Engineering.  The two chapters that I liked in this section were the design and the design patterns chapters.  Chapter 27, Design, is basic software engineering practices in a nutshell.  Something that took me over two graduate level courses to cover, the author gives an overview in about 25 pages.  I recommend this chapter to any novice programmer.  The chapter on Design Patterns is simply put, great.  4 Design Patterns from the popular GoF book are described:<BR>i) Singleton<BR>ii) Factory<BR>iii) Observer<BR>iv) Strategy<BR>A reader can benefit the specific examples that are given in this chapter as they apply to Web site design and implementation.  The examples given are reusable and would benefit any user of PHP.  <BR>Throughout the book the author does a very good job at showing the reader what the differences between PHP and other languages are.  I think PHP would be a very good first language to learn b/c it has all the features of other popular scripting languages such as Perl and structural/OO languages such as Java and C/C++.	2003-10-31
US	50487699	RKFX0RADWXEF7	0321200683	978320311	Enterprise Integration Patterns: Designing, Building, and Deploying Messaging Solutions	Books	5	112	119	N	N	Patterns - revisited	To do justice in reviewing this book, I should depict every single pattern and give you multiple examples on how it would apply to your job as a Project Manager, Software Architect, Technical Lead or a Developer.  That would be a 500-page book all by itself.  In short, this is one great book.  The first book to actually take a complex and ever growing topic such as MOM, Message Oriented Middleware, and give you its benefits and the best practices/patterns all in one book.  <br />The author starts by giving the reader the top reasons why messaging should be chosen for the next project:<BR>1) Remote communication<BR>2) Platform/Language Integration<BR>3) Asynchronous communication<BR>4) Variable timing<BR>5) Throttling<BR>6) Reliable Communication<BR>7) Disconnected operation<BR>8) Mediation<BR>9) Thread Management<BR>The author goes into detail on each of these reasons.  These reasons would convince any software architect, but the author goes even further than that and reiterates the benefits of each of these reasons and elaborates on them thru out the book.  <br />Chapter 3 of the book starts by breaking up a messaging system into its main components and briefly explaining each one:<BR>1) Message Channel<BR>2) Message<BR>3) Pipes and Filers<BR>4) Message Router<BR>5) Message Translator<BR>6) Message Endpoint<br />Each of these high level topics is then broken down and various patterns are shown for each section.  Just like the GoF book, the reader can simply go the desired section and read the patterns that are associated with that \\"subsystem\\"<br />Each section is then followed by a full-blown example, which to me is priceless.  The examples are shown using the most popular middleware vendors such as TIBCO, IBM, Microsoft, Web Methods, SeeBeyond and a couple JMS vendors.  The examples show the similarities and differences in implementation but clearly show how EACH pattern that was just covered in the previous section applies to the example.  <BR>Having worked withmany of the MOM vendors covered in this book, Chapter 7, Message Routing, is my favorite chapter.  The author breaks down this topic into 14 different patterns:<BR>i) Pipes and Filers<BR>ii) Message Router<BR>iii) Content-Based router<BR>iv) Message Filter<BR>v) Dynamic Router<BR>vi) Recipient List<BR>vii) Splitter<BR>viii) Aggregator<BR>ix) Resequencer<BR>x) Composed Message Processor<BR>xi) Scatter-Gather<BR>xii) Routing Slip<BR>xiii) Process Manager<BR>xiv) Message Broker<br />The chances are, not many of us need to write a MOM due to the fact that there are many vendors out there that are doing that already! But one could certainly use this section for education purposes, and/or use it a checklist of \\"nice-to-haves\\" when shopping around for a MOM vendor.  By reading the book, you can figure out what \\"features\\" apply to you, your application and your enterprise, and take that list and see which vendor has implemented that feature.    <BR>In summary, Gregor Hohpe and Bobby Woolf have done a fantastic job depicting a very complex topic.  I have made a place for this book right next to the original GoF Design Patterns book.	2003-10-29
US	50487699	R2PGC8RVUGR0TP	0131429019	352986976	The Art of UNIX Programming (The Addison-Wesley Professional Computng Series)	Books	5	20	30	N	N	Filled with good stuff	By reading this book, one can truly realize the greatness of the Unix operating system and all of its glory.  How it has revolutionized the software and more specifically the Operating System industry over and over again for the past 30+ years.  <BR>This book has four parts, and each part is packed with useful information... The first part talks about the philosophy, the history and background of Unix.  It's a very easy read and it familiarizes the reader the background of Unix and what will be covered in the rest of the book.  Basic rules that Unix was based upon and their explanations are to me, the highlight of the first section.<br />Part 2, focuses on the various design rules and philosophies that were covered in part 1.<BR>It is packed with small, easy to read and understand case studies that explain the design philosophy that was just explained.  It is very interesting to see that some of what we call &quot;best practices&quot; today have been around for years and years in the Unix community and have been perfected thru out the years.  Very valuable to any software architect.  It will give you some ideas what has been done and what not to do when you are designing a piece of software - b/c the chances are that it has been implemented in Unix before.<br />Part 3 goes into a great depth trying to explain the various options programmers have when developing for Unix.<BR>Considering that an entire volume can be dedicated to this section, the author does a great job in explaining the various options for developers.  Keeping the philosophies mentioned in part I, the author conveys the pros and the cons of various programming languages, scripting languages, took kits, etc...<br />Part 4 covers odds and ends of this topic.  It gives you tips on how to work with the Open Source Community and what you need to do if you want release code into the open source community.  The tips are also very valuable even if you are developing software for your company...  One of my favorite sections in part 4 was when the author talks about the various licenses and their differences and how to choose one.  With all the lawsuits surrounding the Unix community, it's good for every developer to know what options are available out there.	2003-10-18
US	50487699	RKUYCIUDYGT8	0201485184	893829554	Essential C++	Books	3	0	4	N	N	An OK refresher even for savvy C++ users	This book touches on important topics of C++.  If you are a savvy C++ user and use it all the time, you won't get a whole lot out of it, but you can certainly use it as a refresher - a very quick refresher.  If you are new to C++ or you have not used it in a while, this book will be very useful you as it is packed with lots of info.	2003-10-10
US	50487699	R1AHNT5TLESRGZ	0201100886	252944232	Compilers: Principles, Techniques, and Tools	Books	5	3	3	N	N	Yet another reviewer	What can you say about a book that has 41+ reviews, and all with close to perfect marks?  <BR>I bought this book not as it required so by almost any and all classes that teach about compiler design, but because I was interested in compilers and didn't have a chance to take class as part of my degree.  It's a great book.  Explains things well, and there are enough supporting material on the web that you can do a self paste study on your own and still get a lot out of this book.	2003-10-10
US	50487699	R27LSR8TWC74FT	0201357429	415913469	Network Management: Principles and Practice	Books	5	1	3	N	N	Covers the topic well	This is a good book to buy that covers the topic of NM.  It is packed with examples and useful information and references.  It covers the old standards and it shows how the standard has progress over the years.  The references are great also; b/c there is so much to say about this topic.  <BR>I liked it, use it to this day for reference...	2003-10-09
US	50487699	RVV9T8MFWZ5EM	0201734842	508997787	C++ Templates: The Complete Guide	Books	5	9	9	N	N	Great book on templetes	Actually, the ONLY book on this topic, that covers the topic well actually...  This book will be the bible in the topic, and it should .. Very well written packed with examples and how to's, etc...  Great learning experience.  For c++ people, you should read this book, and go right to Modern C++ Design.  A very good combo.  One of the best things about the book is that it had a section dedicated on some of the futures changes to this topic as templates are still fairly developing.  You know what to expect if you are an architect.	2003-10-09
US	50487699	R32COTQEMQFDR7	0471986151	240178130	Lingo Sorcery: The Magic of Lists, Objects and Intelligent Agents, 2nd Edition	Books	1	1	1	N	N	This book has nothing to do with AI or IA's	I made that mistake, and wasted my money.  Be aware.  This book does not cover AI or Intelligent Agents in the traditional sense.	2003-10-09
US	50487699	R2WHBK3PDTN6BZ	0201834545	246872019	Inside the C++ Object Model	Books	5	5	5	N	N	Great for any serious C++ user	If you have been using C++ for a while now, and you REALLY want to know what is going on under the hood, read this book - and gain and again until you have memorized it.  As a software architect, I use this book almost on a daily basis - most of the time to prove my case and to show what is really going on behind my design decisions.  <BR>The benchmarks are useful as they really show you what the difference between C, C++ is with various compilers.  I have referred to those benchmarks more times than I can remember.	2003-10-09
US	50487699	R2TDK2ZBGA7UKD	0201485184	893829554	Essential C++	Books	3	0	4	N	N	An OK refresher even for savvy C++ users	This book touches on important topics of C++.  If you are a savvy C++ user and use it all the time, you wont get a whole lot out of it, but you can certainly use it as a refresher  a very quick refresher.  If you are new to C++ or you have not used it in a while, this book will be very useful you as it is packed with lots of info.	2003-10-09
US	50487699	R1XWI3R4C75UKR	0130290491	927072014	Software Engineering: Theory and Practice (2nd Edition)	Books	4	2	2	N	N	Good book - not at first though	If you HAVE to read this book, you'll know what I mean.  The first time I read this book, I hated it... Boring, and one reviewer is right, it covers EVERYTHING under the sun about S/E.  Now, after about two years or so, I keep finding myself refering to this book over and over again.  I am liking more now that I see how and where to use the topics that it talks about.  4 star, b/c this book could have been written better.  First time around was very boring.	2003-10-09
US	50487699	R349VLI83NRACU	0201100886	252944232	Compilers: Principles, Techniques, and Tools	Books	5	0	3	N	N	Yet another reviewer	What can you say about a book that has 41+ reviews, and all with close to perfect marks?  <BR>I bought this book not as it required so by almost any and all classes that teach about compiler design, but because I was interested in compilers and didn't have a chance to take class as part of my degree.  It's a great book.  Explains things well, and there are enough supporting material on the web that you can do a self paste study on your own and still get a lot out of this book.	2003-10-09
US	50487699	R2NA6F21QP2X2O	0201634600	743990466	Design by Contract, by Example	Books	5	5	5	N	N	Great book. Great authors	I had a class with Dr. McKim as part of my requirements for my Masters.  He is VERY good.  I must say, I am little biased here, but I liked him as a lecturer and I bought this book as soon as it came out and I love it.  I had never actually used the concept of Design by Contracts anywhere until my class with Dr. McKim.  If you are a developer or an architect for any OO based language (Eiffel, c++, java, ), you read this book and use it as your reference.	2003-10-09
US	50487699	R1GI0BTARAIKPR	0201485184	893829554	Essential C++	Books	3	2	4	N	N	An OK refresher even for savvy C++ users	This book touches on important topics of C++.  If you are a savvy C++ user and use it all the time, you won't get a whole lot out of it, but you can certainly use it as a refresher - a very quick refresher.  If you are new to C++ or you have not used it in a while, this book will be very useful you as it is packed with lots of info.	2003-10-09
US	50487699	R30Y9AMOHMLCAO	0201834545	246872019	Inside the C++ Object Model	Books	5	5	5	N	N	Amazing book on the internals of C++	If you a series C++ programmer, you need this book.  It's one level of abtraction above knowing how compilers work, and one level of abstraction below any advanced C++ book.  It tells you what the compiler generates, and how much will is cost.  Speed comparisons, and all.  Object models of Inheritance, multiple inheritance, virtual inheritance, and the underlaying structure of how these things work.  Great C++ book...	2003-09-24
US	50487699	R2IOJ1M8DISQAR	0201604647	326821619	1: C++ Network Programming, Volume I: Mastering Complexity with ACE and Patterns	Books	5	2	4	N	N	Good ACE overview	I have been trying to learn ACE for the past few months now.  Their docs are not that great.  I ran C++ doc generator on the API's and that helped alot.  The book really closed the deal for me.  I work with many customers that are just begining to use ACE and I recomended this book to them as well.	2002-11-28
US	50487699	R21B5KDF2BJ0XD	013490012X	355328388	UNIX Network Programming: Networking APIs: Sockets and XTI; Volume 1	Books	5	0	1	N	N	The Bible in this topic	I am a network programmer and this book is truly the bible in this subject.  I have read the first edition and bought the second edition to gain an understanding of the new topics such as IPv6.  If you are doing any kind of network programming where you need to know TCP or UDP or Multicasting in general, this is THE book.  I highly recommend it.	2002-03-19
US	50487699	R1X2ORD02QG9Z	0201704315	109366717	Modern C++ Design: Generic Programming and Design Patterns Applied	Books	5	3	5	N	N	good book to read after the GoF book	This book was really hard to read b/c it was the first book I read about Templates.  I liked it.  It took me a while to get thru the book, but it was well worth the effort.	2001-12-26
US	50487699	RATU0H0I8FFWX	0201707101	89816065	The Rational Unified Process: An Introduction (2nd Edition)	Books	4	0	0	N	N	Great book	This is a great book.  It was the first book that actually described RUP, besides the documentation.  It's a good and an easy read, and you'll know hat RUP is all about after you have read the book.  You will need to practice just like anything else, but this book is a very good starting point.  The newer versions of this book is much better, so buy that instead.	2001-12-26
US	50487699	R2XPTQYUJMHAW7	1861003013	936921516	Professional Linux Programming	Books	4	6	6	N	N	Good reference	I bought the Beginners Guide to Linux Programming and I really liked that book.  This book is a very good follow-up, but it doesn't give the reader more programming tips.<BR>It covers many topics which makes this book a great reference for anyone who deals with Linux and even other flavors of Unix on a day to day basic.  Buy this book if you are looking for a reference book on developing software on Linux that covers advanced topics.	2001-09-07
US	50487699	RTQDNJ98CEO2M	0195014766	459752409	The Art of War	Books	4	3	4	N	N	Ok book	I wanted to know if everything I had heard about this book was true.  Well, everything you have heard IS true.  I was amazed that some of the management techniques are still used to this day. Some of the things that the book talks about do not apply to today's world, however.  Very lite reading, and one could finish this book in one day.  It is a good book to read at least once.	2001-05-27
US	50487699	R1Z84OY1EDJ5U3	0679762884	227905124	High Output Management	Books	5	4	9	N	N	Good book of management techniques	This was a good book.  I was not able to apply all of the techniques, but most of it came in useful.  I always liked what Andy Grove did with Intel, his visions and his capability to keep Intel on the top.  It's a good book.  Read it.  It will take you a couple of days, but you will be a better person after you have read it...	2001-05-01
US	50487699	R2G7EECID3TI5Y	1861003021	155480207	Professional Apache	Books	5	0	1	N	N	Overall, a great book on Apache	I liked this book.  It was practical and it told me everything I needed to know about the internals and how to setup apache in general.  I have been trying to get a book on Tomcat and Apache, but this was not it.  Other than that, it told me all I needed to know about Apache, its modules, and its setup and operation.	2001-05-01
US	50487699	RBCGVLZHTY50Y	0471376817	426677793	JavaTM Programming with CORBATM : Advanced Techniques for Building Distributed Applications	Books	5	5	6	N	N	A Must Have	All of the other books cover old versions of CORBA, but this book covers only CORBA 3.0.  The examples could be better, but that's ok since the topics are so well covered.  I read the first few chapters, and now I use this book as reference all the time.  I highly recommend this book to any Java programmer.  If you are a C++ programmer, this book can still be useful but not much.	2001-03-31
US	50487699	RUXPHXMZI63DR	0072118636	576975276	Oracle JDeveloper	Books	2	4	4	N	N	Does't tell you anything you couldn't figure out	I use Jdeveloper at the office, and I thought that this book could help me with some of the finer points of using this software package.  It did not.  It touches on the basic stuff, but if you want to create any EJB components and deploy them, this book is no good for you.  There is a book from Oracle that is targeted from development for 8i and it is more useful to a developer.  The topics that this book covers are very trivial and out of date for the most part (Jdeveloper  1.x).	2000-11-07
US	50487699	R1IHGE3VOZ69IH	020161622X	158694092	The Pragmatic Programmer: From Journeyman to Master	Books	5	4	5	N	N	It knocked some sense into my head!	Very well written.  It uses common sense to prove its points.   I read the book in one day, and I found it to be very helpful with everyday programming practices.  This book references \\"The Mythical Man-Month\\" in a couple of occasions.  I bought that book as well; was not too impressed with it.  This book, Pragmatic Programmer, is much better and much more reader friendly.  I recommended it to all of my co-workers.	2000-10-30
US	50487699	R3E5PZZGM3IJ1X	007134750X	443021877	The Project Manager's Desk Reference	Books	5	33	34	N	N	Great book for anyone	I bought this book after researching the [project management] topic for months.  The book is very easy to read, and gets to the point very quickly.  By the third chapter, you have a very good idea of what you are up against.  If you are already in the middle of a project, you can use this book as a very good checkpoint.    I am novice in the project management role and I found this book to be very handy and resourceful.	2000-10-26
