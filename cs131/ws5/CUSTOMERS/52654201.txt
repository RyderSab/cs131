US	52654201	R1DSTLIUQEX62I	026269218X	453928561	How to Build a Beowulf: A Guide to the Implementation and Application of PC Clusters (Scientific and Engineering Computation)	Books	3	4	8	N	N	Broad introduction to PC clusters	A \\"Beowulf\\" is the concept of using a network of low cost personal computers for distributed processing. The book doesn't specify a particular configuration. The author describes the three fundamental parts of a Beowulf system: node hardware, network hardware, and parallel software applications. Three chapters explain how to use the message passing interface (MPI) standard to distribute the work for a program executing on multiple nodes. An example MPI program for sorting is presented. The features of the Linux operating system are covered in Chapter 4 since Linux is a common choice for Beowulf clusters.	2002-11-16
US	52654201	R1E9Q0XVJQ2A0Q	0971288712	987409235	Software Optimization Cookbook: High-Performance Recipes for the Intel Architecture	Books	4	9	10	N	N	SIMD using Intel Tools	This text demonstrates how the Intel C++ Compiler and Intel VTune tools can be used for profiling and optimization. The text also dives into CPU specific issues such as the pipeline, memory cache, branch prediction, instruction latencies, instruction throughput, and register stalls. My favorite part is the description of four methods for implementing SIMD instructions on pages 23-26. The methods are automatic vectorization, C++ classes, intrinsics, and inline assembly language.<br />The author covers some traditional optimization topics such as hotspot detection, algorithms, loop unrolling, loop invariant work, and slow operations. The author does not mention the high cost of disk operations. An introduction to multiprocessing gives advice on executing instructions in parallel with threads. A case study in Chapter 16 & 17 demonstrates the process of optimizing a sample application.	2002-11-12
US	52654201	R23O5Y5KFZAJEN	0132398729	284807483	Object-Oriented Metrics: Measures of Complexity	Books	3	2	3	N	N	Combines practical metrics and academic theory	Research findings in the field of software measurement are thoroughly reviewed. Both traditional and object-oriented product metrics are examined. Methods for determining the mathematical validity of metrics area assessed in the chapter on \\"A Rigorous Approach to Metrics\\". Intriguing presentation of cognitive complexity models including an analysis of programming tasks, code chunks, and code landscape.	2002-11-08
US	52654201	R2G2F359CYR424	013179292X	768724245	Object-Oriented Software Metrics	Books	4	2	3	N	N	Relates metrics to quality	Defines a set of 39 metrics classified into 9 project metrics and 30 design metrics. The author explains how design metrics can be used to detect quality problems and offers recommended thresholds. Advice is provided on how to correct problems with the design and source code. A project experience database displays metrics for real projects in Smalltalk and C++. The book is relatively short at 146 pages.<br />The metrics covered in the text are number of scenario scripts, number of key classes, number of support classes, average number of support classes per key class, number of subsystems, average person-days per class, average number of classes per developer, number of major iterations, number of contracts completed, number of message sends, number of statements, lines of code, average method size, method complexity, number of public instance methods in a class, number of instance methods in a class, average number of instance methods per class, number of instance variables in a class, average number of instance variables per class, number of class methods in a class, number of class variables in a class, class hierarchy nesting level, number of abstract classes, use of multiple inheritance, number of methods overridden by a subclass, number of methods inherited by a subclass, number of methods added by a subclass, class cohesion, global usage, average number of parameters per method, use of friend functions, percentage function-oriented code, average number of comment lines per method, average number of commented methods, number of problem reports per class or contract, class coupling, number of times a class is reused, and number of classes/methods thrown away.	2002-09-12
US	52654201	RI09LJG2WIQJ6	0201199300	491540425	Software Architecture in Practice	Books	4	3	4	N	N	Emphasis on case studies	The authors examine 7 case studies representing 37% of the 19 chapters. \\"The software architecture of a program or computing system is the structure(s) of the system, which comprise software components, the externally visible properties of those components, and the relationships among them (pg 23).\\" Describes common structures for example module structure, conceptual or logical structure, process or coordination structure, physical structure, uses structure, calls structure, data flow, control flow, and class structure. Explains how choosing architecture influences the achievement of quality attributes. Illustrates architectural styles such as batch sequential, pipes & filters, event systems, repository, virtual machine, and object oriented.	2002-09-12
US	52654201	RPBECX0LTMXPS	0471363669	351043454	AntiPatterns in Project Management	Books	2	4	6	N	N	Boring	This book is dull compared to the first book in the series, \\"AntiPatterns: Refactoring Software, Architectures, and Projects in Crisis\\". The authors take a reactive instead of proactive approach to project management. Read the four page antipattern synopsis in appendix B. The rest of the book regurgitates these items in expanded form. The text concentrates on project management problems and offers little in the solutions section. The antipattern named \\"standards\\" was helpful, however the material was duplicated from James Moore's book \\"Software Engineering Standards: A User's Roadmap\\".	2002-06-20
US	52654201	R2J9NHQRGXTXRB	0131829572	451444703	Software Architecture: Perspectives on an Emerging Discipline	Books	3	11	16	N	N	Architectural paradigms and research topics	This book is often cited as one of the seminal references on software architecture. The first chapter explains how software architecture fits into the developing field of software engineering. The second chapter illustrates common architectural styles such as pipes and filters, object-oriented organization, event-based invocation, layered systems, repositories, interpreters, process control, distributed process, main program/subroutine, blackboard, and state transition. Case studies are used to compare and contrast the selection of different architectural solutions. The case studies are key word in context, instrumentation software, mobile robotics, cruise control, three vignettes using mixed styles, and shared information systems. The final half of the book is focused on academic research such as quantified design space, formal models, formal specifications, Z notation, connector models, automated case tools, Wright Model of architectural description, and education of software architects.	2002-06-05
US	52654201	R1DUMYQXOHCTQO	1852331593	153597436	The Interpretation of Object-Oriented Programming Languages	Books	4	0	0	N	N	Refreshing conceptual analysis	Use this text to study the conceptual basis of object-oriented programming. The author defines objects, classes, instances, slots, methods, inheritance, pure vs. impure languages, visibility, accessibility, encapsulation, abstraction, delegation, prototypes, actors, iterators, subtyping, multiple-inheritance, mixin classes, interfaces, aggregation, dynamic binding, polymorphism, genericity, overloading, overriding, downcasting, containers, reflection, and meta class. Variations in the implementation of these features in both common and obscure object-oriented programming languages are analyzed. The text covers three language approaches: class-based, prototype, and actor. The author familiarizes the reader with a broad array of programming languages such as Ada, Beta, C++, CLOS, Dylan, Eiffel, Java, JavaScript, Oberon, Omega, Sather, SELF, Simula, and Smalltalk. The book has an academic orientation. Practitioners will be imparted with a deeper and broader understanding of object-oriented principles after digesting this text.	2002-06-04
US	52654201	R1CH7Y4P12FY3O	0132366134	687908813	Journey of the Software Professional: The Sociology of Software Development	Books	5	1	1	N	N	Effective techniques for software professionals	Luke Hohmann explains three aspects of the software development journey: inward focus, outward focus, and upward focus. Principles from psychology are used to demonstrate how the reader can achieve personal growth and develop skills as an engineer or manager. Practical advice for staff and management is prominent at the end of each chapter. Cognitive models, values, personality, goals, culture, strategy, rituals, future perfect thinking, domain experience, competency frameworks, learning styles, training plans, the Johari Window, organizational cohesion and coupling, topology, and roles are discussed in the context of software engineering. The structure, process, outcome (SPO) framework for organizing a software project is a constant thread.	2002-02-14
US	52654201	R3GPBIN1FPCIQA	0735608776	678153780	After the Gold Rush: Creating a True Profession of Software Engineering (DV-Best Practices)	Books	4	2	5	N	N	Software engineering as a profession?	Uses the analogy of moving stone blocks to illustrate how smart teams continuously look for ways to work efficiently. The author explains how the code-and-fix development pattern is fool's gold. The relationships of computer science vs. software engineering and engineering vs. art are analyzed. Software engineering is defined as the application of scientifically developed and mathematically defined algorithms, functional design methods, quality-assurance methods, and other practices to the development of software products and services. The SW-CMM rating system is explained including the performance benefits of a Level 5 organization. Table 9-1 examines the current status and maturity of software engineering as a profession in the categories of initial professional education, accreditation, skills development, certification, licensing, professional development, professional societies, code of ethics, and organizational certification. An outline for the software engineering body of knowledge is presented. The licensing and specialization of professionals acts as a filtering system. The chasm between &quot;early adopters&quot; and &quot;early majority&quot; in technology innovation is analyzed in respect to the software engineering profession.	2001-10-31
US	52654201	R3PZEUOCPIYIUP	0130266922	112193205	Software Cost Estimation with Cocomo II	Books	5	21	22	N	N	A stalwart of software engineering modeling	The latest revision of the well known COCOMO constructive cost model is calibrated with a Bayesian approach that balances 161 industry reference points with the determination of software development experts. Software engineers use the COCOMO model to make financial decisions, set project budgets and schedules, negotiate tradeoffs, plan to maintain or upgrade legacy products, and decide where to implement process improvement. The model equations are provided including normative calibration using 5 scale factors and 17post-architecture effort multipliers. The criteria described for assessing your project for scale factors and effort multipliers are fuzzy in some cases (Default to the nominal level when in doubt). The model can accept estimates of either logical lines of code or function points as the primary input parameter. The book is accompanied with a CD that contains the USC implementation of the COCOMO model and some instructional videos. The final 2/3 of the text covers emerging extensions such as object point data, application point data, phase schedule and effort model (COPSEMO), dynamic COCOMO, RAD schedule estimation model (CORADMO), commercial-off-the-shelf integration model (COCOTS), quality estimation (COQUALMO), and productivity estimation (COPROMO). Read &quot;Software Engineering Economics&quot; published in 1981 for additional background information on the COCOMO model.	2001-09-23
US	52654201	R2RS6UV20NN1TE	0471314811	975234351	Advanced COBOL for Structured and Object-Oriented Programming, 3rdEdition	Books	5	9	9	N	N	Classic guide to programming in COBOL	As a C++ programmer working on a product with 2 COBOL components (2/90), I found this text to be an indispensable COBOL reference. The author classifies language constructs into essential, sometimes used, rarely used, and archaic. The text is comprehensive including reserved words, program constructs, tables, indexed files, dates, Y2000, report writer, and client-server architecture (one exception is limited coverage of CISCs transaction processing). Both PC and mainframe COBOL environments are covered. Organizing COBOL code into paragraphs, sections, subprograms, functions, and classes (object-oriented is not yet standardized) is demonstrated.<br />The text illustrates each COBOL feature with either a code fragment or a sample program. A well-conceived programming style for COBOL is recommended using structured programming. A coherent discussion of archaic programming styles helped me comprehend areas of our COBOL code where periods are used instead of END-IF statements.	2001-08-04
US	52654201	R6DIV1Z73ACZ2	0138221227	834643540	Software Engineering Economics	Books	5	9	12	N	N	Economic analysis of software decisions making	A classic reference on estimating the cost of software projects, economic analysis techniques, and applying economic principals to upper-level management of software projects. The intimidating appearance of the text on initial inspection is overcome by the author's excellent organization of the content into small chapters and his lucid writing style. The definition of a software cost model called the constructive cost model (COCOMO) is a major centerpiece. Another centerpiece is the chapters on cost-effectiveness analysis, multiple goal decision analysis, dealing with uncertainties and the value of information, software project planning and control, and improving software productivity. Alternatives to cost models such as experts, analogy, Parkinson, price-to-win, top-down, and bottom-up are discussed in Chapter 22. Uses several case studies for example a transaction processing system. Contains an excellent set of questions and exercises at the end of each chapter.<br />The COCOMO model is calibrated by industry data and expert opinion. Given module size estimates in lines of code as input the COCOMO model will predict effort and schedule in man-months.  The COCOMO predictions cover the plans, product design, programming, and integration &amp; test portions of the life cycle. The validity of the model is illustrated by charting actual vs. COCOMO prediction and the detailed analysis of the COCOMO cost driver attributes in Chapters 24-26. Product attributes are required software reliability (RELY), data base size (DATA), and product complexity (CPLX). Computer attributes are execution time constraint (TIME), main storage constraint (STOR), virtual machine volatility (VIRT), and computer turnaround time (TURN). Personnel attributes are analyst capability (ACAP), applications experience (AEXP), programmer capability (PCAP), virtual machine experience (VEXP), and programming language experience (LEXP). Project attributes are modern programming practices (MODP), use of software tools (TOOL), and required development schedule (SCED).<br />Readers should be aware that some aspects of the COCOMO have been replaced by the publication of the \\"Software Cost Estimation with COCOMO II\\" book. The \\"COCOMO II\\" book contains a preface section titled  \\"Relation to 1981 Software Engineering Book\\". I recommend keeping a copy of this preface handy while you read \\"Software Engineering Economics\\" because it provides a chapter-by-chapter assessment of the relevance of the \\"Software Engineering Economics\\" content in the year 2000.	2001-06-27
US	52654201	R2HD0D206TZU18	0201633620	614486548	Large-Scale C++ Software Design	Books	5	2	2	N	N	An excellent analysis of physical design.	This comprehensive reference covers all aspects of physical design in C++. The material is relevant to all C++ projects however the effects of poor physical design are amplified in large-scale projects. John Lakos illustrates how to eliminate cyclical dependencies, excessive link-time dependencies, and excessive compile-tine dependencies. Provides guidance for organizing the content of header files. Covers components, physical hierarchy, levelization, encapsulation, insulation, and packages. As a bonus the author includes an excellent essay on designing a function interface specification including the following tradeoffs: operator or non-operator function, free or member operator, virtual or non-virtual function, pure or non-pure virtual member function, static or non-static member function, const or non-const member function, public, protected, or private member function, return by value, reference, or pointer, return const or non-const, friend or non-friend function, and inline or non-inline function. Includes a dependency extractor/analyzer package in appendix C.	2001-06-13
US	52654201	R28NX3MHK7MDLW	0201546108	184800752	A Discipline for Software Engineering	Books	4	15	15	N	N	Explains the personal software process (PSP)	Analyze your personal software development performance as a self-improvement initiative. Categorize time in phases and record the amount of time spent on each assigned task in each phase. Develop historical databases of size and productivity as illustrated by the project-planning framework (Fig 5.1). Compare initial estimates of size, effort, and schedule versus actual size, effort, and schedule (management metrics). Track defects, classify defects, identify problem components, and establish reliability measurements (product metrics). Presents the goal-question-metric, design and code reviews, cost-of-quality measures, unit testing, defect prevention strategies, and verification process. Includes a set of exercises that put the PSP program into practice. The appendix contains an excellent section on statistical techniques and a complete set of forms and instructions for implementing the various PSP measurement programs. Some questionable practices: the author insists on counting compiler errors as defects, the author uses compiler errors in reliability metrics calculations, and the author recommends performing a code review before compiling the program.<br />A quote from the author, \\"In addition to providing the data you need to handle management pressure, the PSP offers many other potential benefits as follows: The insight you gain into your talents and abilities; The stimulation of an almost unlimited stream of improvement ideas; The framework it provides for personal improvement; The degree of control you gain over your work; The feeling of pride and personal accomplishment; An improved basis for effective teamwork; The conviction to do the job the way you know you should.\\"	2001-05-23
US	52654201	R29RQGJ4H50G8V	013624842X	927072014	Software Engineering: Theory and Practice	Books	5	5	8	N	N	Well-conceived introductory text	Organizes chapters according to a traditional software development sequence: introduction, process and life cycle, planning and managing, requirements, design, implementation, testing, delivery, maintenance, evaluation, and improvements. Includes extensive references to research papers and standard texts. An information system (scheduling television advertising) and real-time system (Ariane-5 rocket) example are threaded through each chapter. Compares effort estimation models including COCOMO II and neural-networks alternatives. Discusses architectural styles and strategies. Includes an excellent chapter on software maintenance and software rejuvenation. Explains system types such as S, P, and E. Analyzes methods for evaluating the results of software engineering research. Presents research on policy trade-offs such as \\"adjusting the workforce to keep the project on schedule\\" vs. \\"extending the schedule as needed.\\" The coverage of specific structured and object-oriented methods is minimized.	2001-04-19
US	52654201	R3RLCDAV7SQGWV	0672319225	189903266	Understanding SOAP: The Authoritative Solution	Books	4	9	12	N	N	technology for web applications	Excellent  presentation of fundamental  SOAP technology in chapters 1-7 (193 pages). Explains how the SOAP protocol and request/response model can be used in web applications. Compares SOAP with CORBA and DCOM. Illustrates the contents of SOAP request and response messages. Presents an ISAPI extension for monitoring SOAP traffic (debugging &amp; development). Defines XML content of SOAP messages and shows how to package data types using XML types including base64 for data structures. Introduces approaches for managing state-information in a SOAP based application. Chapter 8 explains how Microsoft's BizTalk Server uses SOAP technology.  Briefly discusses the philosophy of Microsoft's SOAP toolkit. Chapter 10 presents code for creating a transparent framework for COM objects which are unaware of SOAP to be called through the SOAP protocol. Chapter 10 covers at least 1/3 of the book, is difficult to understand, consists primarily of code, and occasionally drops into assembly language for unexplained reasons.	2001-04-01
US	52654201	R1HMZC6QQOIPQQ	0070521824	411433236	Software Engineering: A Practitioner's Approach	Books	5	1	4	N	N	comprehensive coverage of software engineering	The author achieves a commendable balance between breadth and depth. None of the topics are discussed at a superficial level. In addition, this text is written in a highly readable style. External sources are frequently referenced, quoted, and summarized. There is an emphasis on software metrics in chapter 5 and chapter 18. A section on structured methods is contained in chapters 11-14. A section on object-oriented methods is contained in chapters 19-23. Excellent introduction to advanced topics such as formal methods, reengineering, client/server, and computer-aided software engineering. Breaks CASE tools into 23 categories. Each chapter includes a set of  problems and points to ponder.	2001-04-01
US	52654201	R1TW1RGXNIJ1MX	0130850837	765190676	Creating High Performance Software Development Teams	Books	4	2	3	N	N	Fundamental aspects of software management	123 pages. A refreshing and quick read covering the fundamental aspects of software management. Guidance on building a high performance team through hiring qualified developers, matching skills with positions, training, and harnessing individual strengths. Discusses software developers as people instead of as resources. Presents hierarchical, flat, and matrix organization structures. Illustrates the importance of requirements gathering, return on investment (ROI) calculations, and planning. Distinguishes between management and leadership. Explains how to execute with passion and keep the project on track by managing the critical path. The author uses relevant analogies and personal stories in a few places to illustrate the points. Watch out for the \\"chasing the shiny coin syndrome.\\"	2001-03-08
US	52654201	RATM7QL3RUZA6	0201924889	971698755	Effective C++: 50 Specific Ways to Improve Your Programs and Design (2nd Edition) (Addison-Wesley Professional Computing Series)	Books	5	1	1	N	N	Isolates 50 important C++ concepts	The author has broken from the conventional approach by isolating his content to specific C++ items instead of presenting the entire language. Each point is well written with justifications and examples. The majority of the items (48/50) are must-know concepts for effective C++ software development. Exceptionally meaningful content includes 7 items on constructors, destructors, and assignment operators, 11 items on class design and function declaration, and 10 items on inheritance and object-oriented design. Excellent guidance for selecting the correct approach from amongst a wide-variety of advanced C++ features. \\"Effective C++\\" is one of the best intermediate level C++ books.	2001-03-08
US	52654201	RVBP59IT54CWN	1887902600	894325622	Persuasive Programming	Books	3	11	11	N	N	Techniques for illustrating program correctness	Persuasive programming steps in the direction of formal methods while not requiring a proof. These techniques are presented as a solution to \\"programming by approximation\\" which can afflict students. The primary technique presented is adding assertions, preconditions, postconditions, and invariants to existing programs as embedded comments. A precise postcondition for a complete program can be deduced using the persuasive programming process. The derived postcondition, representing the inherent semantics of the program, can be compared to the original postcondition, which represents the intended semantics. If they are the same then confidence in the program's correctness has been established.<br />Chapter 14 presents a full program with the persuasive programming style. Chapters 3-13 present the methods of asserting building blocks, simple statements, selection, repetition, and abstraction. Deducing code from assertions is briefly covered as an advanced technique. The appendix contains an excellent description of Boolean logic.  The authors provided minimal coverage of asserting C++ classes, did not present a C++ class in the persuasive style, and did not present any examples with bugs where the expected postcondition and persuasively derived postcondition don't match. In my opinion, persuasive programs are difficult to read. These persuasive assertions can repeat information that is already evident from the code. One alternative is to use persuasive programming as a code review exercise and then trim down the assertion comments to their minimal form.	2001-02-26
US	52654201	R2FULY5YKGPKNQ	0070342075	213059795	The Elements of Programming Style, 2nd Edition	Books	5	16	16	N	N	A classic programming book	Published in 1978. 168 pages. These 77 rules represent the definitive basis of good programming style and best programming practices. Included in this famous set of rules are gems such as \\"say what you mean\\", \\"write clearly\\", \\"use the telephone test\\", \\"make sure comments and code agree\\", and \\"make it right before you make it faster\\". Each rule is described in the context of a small program or code fragment. The authors expertly illuminate their rules by correcting these deficient programs. All of the example code in FORTRAN or PL/I was taken from prior publications. The rules are programming language independent (76/77); the only exception is \\"avoid the FORTRAN arithmetic IF.\\" This book solidified many of the ideals expressed in the structured programming movement.	2001-02-15
US	52654201	R9ZVX1TPQYNPL	0201563657	849269859	C++ Programming Style	Books	2	9	13	N	N	Introduction to C++ class design	This book does not cover programming style in the traditional usage of the term. There is no discussion of general programming practice, naming conventions, documentation, commenting, formatting, and layout. The best target audience for this book is newcomers to C++ having difficulty with class design. Chapters on abstraction, consistency, inheritance, virtual functions, operator overloading, wrappers, and multiple inheritance provide solid guidance. The author repeats principals in multiple chapters such as \\"Look for simple abstractions\\", \\"Reduce coupling - minimize interactions between classes\\", and \\"Usually, the destructor in a public base class should be virtual\\". Substantial amounts of code listings appear in the book (approximately 20% of the pages).	2001-02-15
US	52654201	R2DUP9XIFYXG7M	0894331981	672759979	Kiss Principle	Books	1	1	1	N	N	Focused on developer tools	Published in 1983. 199 pages. The author delivers lip service to his title \\"The KISS Principle.\\" There is minimal discussion of software design with its associated \\"keep it simple stupid\\" principal.  The first chapter covers the lessons learned from several small projects. This book advocates various software development tools in areas such as project management, diagramming, automatic code generators, structured design, editors, word processors, portable terminals, record management, and email.	2001-02-09
US	52654201	R3SUZHN871ZC0	0911537074	905832496	C Programming Guidelines	Books	3	2	2	N	N	Covers strict portability	211 pages. This list of guidelines is strong in the areas of strict portability and changes to the language from the ANSI C standard. Each guideline is presented with justifications. Small amounts of blank space are provided for the reader to write \\"local notes\\".  In addition to portability guidelines, the book covers readability, consistency, style, and design. The design guidelines were spread throughout the book instead of in a single chapter. The author makes heavy references to his other book, \\"Reliable Data Structures in C\\" which often leaves the reader hanging in mid-stream.	2001-02-07
US	52654201	R3VR4RZ4SD265R	0131168983	654790252	C Style: Standards and Guidelines : Defining Programming Standards for Professional C Programmers	Books	4	1	1	N	N	Alternatives for coding style in C	Distinguishes between commonly accepted practices and areas with several feasible alternatives. The author reserves his example of the ideal standard to the appendix. The chapter on \\"Psychological factors\\" provides many insights into how standards can improve the programming process. Elements such as pattern recognition, filtering, habit, redundancy, cues, context, chunking, the rule of seven, context switching, eye focus, eye movement, looking ahead, looking back, subconscious, and natural ambition can affect both programmer productivity and program correctness. Comprehensively covers commenting, naming, layout, language usage, data usage, and programming usage. This material is also relevant for C++ programmers. Excellent source of ideas for developing an individual, group, or company coding policy.	2001-01-23
US	52654201	R1J9KZHM702IFC	0201379503	736405364	Efficient C++: Performance Programming Techniques	Books	4	31	32	N	N	Keys to acceptable C++ performance	The authors are developers of network and web server software for IBM. They specifically target performance issues related to C++ programming. The primary topics of discussion are constructors &amp; destructors, virtual functions, return value optimization, temporary objects, inlining, memory managers, and reference counting. Learn how to create efficient constructor functions. Learn how to avoid the costly construction of temporary objects. The authors promote \\"lazy evaluation\\" and nail  \\"useless computations\\" and \\"obsolete code.\\" Algorithm and data structure discussions are referred to other standard references, however there is coverage of the STL structures (insertion, deletion, traversal, and find operations). An additional bonus is the excellent coverage of multithreading issues.	2001-01-05
US	52654201	R2Y4A1F0TV73NN	093822803X	791923488	The preparation of programs for an electronic digital computer: With special reference to the EDSAC and the use of a library of subroutines (Charles ... reprint series for the history of computing)	Books	5	4	4	N	N	The first computer programming book.	Originally published by Addison-Wesley in 1951. This book establishes the field of computer programming. The chapters are titled \\"The Design of Programs For Electronic Computing Machines\\", \\"Input of Orders\\", \\"Subroutines and Parameters\\", \\"Library Subroutines and Their Use in Constructing Programs\\", \\"Pitfalls\\", \\"Use of the EDSAC and Its Associated Equipment\\", \\"Examples\\", and \\"Specifications of Library Subroutines\\". The first automatic computer (Harvard Mark I) with mechanical parts and the first automatic electronic computer (ENIAC) were finished in 1944 and 1946 respectively. In 1945 the Moore School of Electrical Engineering, University of Pennsylvania proposed storing instruction codes in memory. This design, called the \\"von Neumann architecture\\", is used by all modern computers. Maurice V. Wilkes, one of the authors, finished building the first stored-program electronic digital computer (EDSAC) in 1949.<br />The EDSAC programmer's (Wilkes, Wheeler, and Gill) were the first to have practical programming experience using the stored-program architecture. The authors establish the subroutine as the fundamental component of source code. They developed the first subroutine library, linker (a mechanical device to copy subroutines to the master program tape), and loader (the initial orders program). In addition, they are the first to design an assembly language, develop formal subroutine specifications, and to use debugging core dumps, single-step debugging facilities, trace statements, desk checking, and syntax checking (a mechanical device to compare tapes). Published the first set of example programs that execute on an actual stored program computer. First use of literate programming and white space for improving program comprehension. [The authors use named boxes to indicate code insertions from the subroutine library. These boxes can also represent other code fragments that are not part of the subroutine library. The programs presented in chapter 7 use the \\"literatestyle\\".]	2000-12-22
US	52654201	R1I4ISD1EQF0GG	0201604787	281199832	Software Configuration Management Strategies and Rational ClearCase(R): A Practical Introduction (Addison-wesley Object Technology Series)	Books	3	5	6	N	N	80% vendor specific	The authors illustrate how the following problems can be solved using a version control tool. Identify and store artifacts in a secure repository. Control and audit changes to artifacts. Organize artifacts into versioned components. Create baselines at project milestones. Record and track requests for change. Organize and integrate consistent sets of versions using activities. Maintain stable and consistent workspaces. Support concurrent changes to artifacts and components. Ensure reproducibility of software builds. <br />The historical background of software configuration management is described in chapter 2. Delta storage mechanisms are described on page 33. The ClearCase tool is described in chapter 3 through chapter 11. Strong emphasis is placed on the UCM process modeled on activities. ClearCase's unique features are not summarized in a single location. The manuals provided by Rational with the ClearCase product are better than the materials presented in this book. The product manuals are also clearly divided between using the UCM and using base ClearCase.	2000-12-20
US	52654201	R27G7UG6F2GX4K	0884050181	922291373	Modular programming	Books	2	0	0	N	N	Design of modules for supporting overlays	This short manuscript has 100 pages. Published in 1972. Modular programming is a system of developing programs as a set of interrelated individual units (called modules) which can later be linked together to form a complete program. The author is primarily concerned with designing modules that can be used together in memory overlays. There is limited discussion of classical principals such as loose coupling and high cohesion. A thought provoking passage from the manuscript says, \\"The splitting of program specifications into modules becomes perhaps the most important function within a department and it is quite common to find Senior Programmers devoting the majority of their working week to program design. At first sight this may seem to be a backward step since it removes from the programming load the most experienced staff. However, this is not the case since most modules will be easy to program, and do not therefore require very experienced staff, and the overall development time saved will easily outweigh any time `lost' by having Senior Programmers doing program design.\\"<br /> An alternative reference, published in 1972, is David Parnas' article titled \\"On the Criteria to Be Used in Decomposing Systems into Modules.\\"	2000-12-19
US	52654201	RBRI8DHX937RA	0672319047	209190667	C++ Footprint and Performance Optimization (Sams Professional)	Books	4	7	7	N	N	Examine performance implications of programming decisions	Concentrates on a broad range of performance optimization techniques. The author strikes a nice balance between programming in-the-large and programming in-the-small techniques. The programming in-the-large chapters discuss language selection (assembly, C, C++, Pascal, Visual Basic, or Java), O notation, memory managers, string searching, sorting, and data structures (arrays, linked lists, hash tables, binary trees, and red/black trees). Includes a lucid analysis of memory managers. Programming in-the-small issues are variable types, variable scope, variable initialization, structures, bit fields, unions, selectors, jump tables, loops, invoking functions, macros, inline functions, iteration vs. recursion, pass by reference vs. pass by value, global data, virtual functions, and templates. Excellent set of charts containing timing comparisons of the various techniques. The source code is available from the publishers web site.<br />There are several lapses in this text. All of the timing charts for comparing the various techniques should have been printed in the book. The third section of the book on avoiding C traps and pitfalls is off topic. Programming in-the-small optimization techniques are not covered comprehensively. One glaring omission is the technique of using a sentinel element as a loop termination signal. The author does not provide a bibliography or references to standard industry texts. At a minimum the sorting and string searching sections should have referenced Donald Knuth?s ?The Art of Computer Programming: Sorting and Searching, Vol. 3? and Dan Gusfield?s ?Algorithms on Strings, Trees, and Sequences: Computer Science and Computational Biology?.	2000-12-15
US	52654201	R2C516Q4O7BUHC	0201615770	950791761	Building Web Applications with UML (The Addison-Wesley Object Technology Series)	Books	4	10	10	N	N	web applications: introduction &amp; UML notation	The first half of the book is an introduction to web applications while the second half of the book illustrates the author's UML extension for designing web applications. The introductory material includes a substantial discussion on the definition of a &quot;web application&quot;. Essential web technologies are discussed in a summarized fashion including HTTP, HTML, forms, frames, session management, DOM, ASP, JSP, scripting, JavaScript, events, applets, beans, ActiveX, RMI, CORBA, DCOM, XML, and security. The only missing item is Adobe's portable document format, PDF, which is a cross-platform document format used in both web sites and web applications.<br />The author has developed a UML extension for modeling web applications. The extension includes stereotypes for a server page, client page, form, frameset, JavaScript object, target, web page, ASP page, JSP page, servlet, and script libraries. Many of these stereotypes have an associated icon. New associations include &lt;&lt;link&gt;&gt;, &lt;&lt;targeted link&gt;&gt;, &lt;&lt;frame content&gt;&gt;, &lt;&lt;builds&gt;&gt;, &lt;&lt;IIOP&gt;&gt;, and  &lt;&lt;RMI&gt;&gt;. The &lt;&lt;builds&gt;&gt; association indicates a dynamically generated web page. The classic &quot;shopping cart&quot; application is designed and implemented. The design includes a set of UML diagrams using the UML extension for web applications. The source code in the implementation uses ASP, VB Script, and HTML.	2000-12-08
US	52654201	RVODKUYNU9BA1	0137299478	166224198	Program Style, Design, Efficiency, Debugging, and Testing	Books	5	1	1	N	N	&quot;Lore of Programming&quot; - from preface	Published in 1978. Each chapter contains a well-conceived set of programming maxims and a thorough set of exercises.  Excellent discussing of commenting techniques and program style. \\"Comments should provide something extra - not just paraphrase the code.\\" Example code fragments are presented in COBOL, FORTRAN, ALGOL, and PL/I. The program design chapter covers simplicity, problem definition, algorithm selection, generality, modest goals, and structured programming. Discussion of issues related to programs stored on punch cards and executed by machine room operators provides a humorous historical context. \\"Large monolithic programs are like a plate of spaghetti: pull it here and something moves on the other side.\\" Spaghetti code issues still appear in the object-oriented programs of the 1990's.	2000-11-05
US	52654201	R39PCLQHYEPZFK	0130844667	44501881	Advanced Java Networking (2nd Edition)	Books	3	1	2	N	N	Compares sockets, RMI, CORBA, and JDBC	The strength of this book is its breadth. An example application, called Calendar Manager, is implemented for each of the technologies such as sockets, Java RMI, Java IDL (CORBA), and JDBC. These choices are summarized and compared in chapter 14, \\"Making an Architectural Decision\\".  In addition, there are chapters on Java server pages, Java Beans, Jini, Java Management API (JMX/JMAPI), LDAP directory services, and Java security.  The content and tone-of-voice have an introductory flavor. The word \\"advanced\\" could be eliminated from the title.<br />The analogies in the book sound condescending and amateur.  An example appears in the Java IDL chapter on page 204, \\"All this is analogous to an ordinary table lamp. There are several lamps in your home, all of which implement the same interface-namely `turn on' and `turn off'. Just because they all implement the same interface doesn't mean that they all must be the same lamp. Indeed, you need many lamps; otherwise, you would trip on your shoes as you went to bed. ... \\".	2000-10-17
US	52654201	RFZT7DVAFGQYK	0136365647	812082560	Software Release Methodology	Books	4	12	15	N	N	Fundamental techniques for releasing a software product	Concentrates on issues related to the delivery of a product such as builds, numbering, distribution, and release planning. Addresses topics associated with a high quality delivery such as source code control, issue tracking, modularized development, and change control. Use this reference to compare your release process with the conventional approach. Excellent discussion of branch management and branching strategies for version control systems on pages 23-32. Explains the usage of a current product tag and a system integrator tag on pages 100-103.	2000-10-15
US	52654201	R1RHFZO068EFNO	085312485X	855729213	Guide to Good Programming Practice (Ellis Horwood Series in Computers and Their Applications)	Books	4	3	4	N	N	These principles stand the test of time	Published in 1984 by British authors. The book starts by reprinting a classic cartoon regarding miscommunication between project sponsor, project requestor, senior systems analyst, programmers, installation team, and end user. There are five chapters covering strategy and design, program writing, program development, special problems, and other people. The \\"special problems\\" chapter includes heuristic programming, large quantities of data, large programs, programs with long run times, and real-time programs. The \\"other people\\" chapter covers program documentation, seeking advice, other people's programs, and working as one of a team.<br />The sections on input-output, man-machine interface, and structured programming can be read for historical interest. Excellent code reviews of an Algol 60 and a Fortran 77. These are fantastic illustrations of what a \\"code review\\" should be. Humorously, the authors improved versions are poor when compared to current programming standards. The section on input-output and man-machine interface discusses punch cards, paper tape, teleprinter, microfilm, magnetic tape, disk file, terminals, line printers, cassette tapes, floppy disks, and direct keyboard entry.	2000-10-15
US	52654201	R15J7PE7CEITIW	1575210495	925225833	Java Unleashed	Books	4	0	1	N	N	describes Java bytecodes	The original AWT for Java is now outdated. Programmers are using the JFC Swing classes. Several chapters in the book are still relevant. &quot;Part I Introducing Java&quot; enumerates the abilities of Java including &quot;Java makes Executable Content Possible&quot;, &quot;Java's Design is Flexible and Dynamic&quot;, &quot;Java Transforms the World Wide Web&quot;, &quot;Java Animates Web Pages&quot;, &quot;Java Makes Web Pages Interactive&quot;, and &quot;Java Distributes Content&quot;. There is good coverage of the fundamental Java language, the Java class libraries, and Java applets. The best chapters are on network programming, the Java virtual machine, and Java bytecodes. For each bytecode, some brief text describes its function, and a textual &quot;picture&quot; of the stack, both before and after the bytecode has been executed, is shown. Good low level stuff!	2000-10-02
US	52654201	R16BGTO07PHY9E	0201700735	298626172	The C++ Programming Language: Special Edition (3rd Edition)	Books	5	1	2	N	N	Concise description of the C++ language	Stroustrup explains the intended usage of each element of the C++  language. He demonstrates reasonable usage of the C++ language with brief  examples. Serves as a complete reference by covering C++ basic facilities,  abstraction mechanisms, the standard library, and design using C++.  Presents the C++ language as standardized in ISO/IEC 14882. This is an  excellent intermediate level book.	2000-09-05
US	52654201	R2QOH9C1KQ0AM1	0876268165	367668124	Software psychology: Human factors in computer and information systems (Winthrop computer systems series)	Books	5	6	6	N	N	psychology, human factors, and research techniques	Illustrates the procedures for conducting software development research using introspection, case studies, and field studies. Presents research findings in areas such as programming style, team organization, group  processes, programmer aptitude, and personality factors. &quot;Software  Psychology&quot; is an important historical reference that covers the  emergence of complexity measures, interactive systems, and the SQL database  query language. Encourages the application of psychological principles to  computer science. Published in 1980.	2000-07-21
US	52654201	RKA55C3QE5VJ1	1568304552	552194451	Forms: Interactivity for the World Wide Web	Books	4	21	22	N	N	interactive forms, internet programming (server)	The first three chapters (100 pages) show you how to create HTML and PDF  forms. The interaction between the browser and the server is explained.   The section titled &quot;Choosing Your Scripting Language&quot;  demonstrates Perl, C, JavaScript, Java, Visual Basic, VBScript, active  server pages (ASP), and Applescript. The final two chapters (518 pages)  contain the following eight examples: business card order, W4 employer  form, 1040 Tax Form, Drivers License Order, Employee Benefits, Stock Photo  Library, Resume Submission, and University Course Enrollment. The server  scripts are written in Perl. The discussion of creating form fields in  Acrobat Exchange bogs down the examples. However, the examples demonstrate  important web programming techniques such as creating forms, creating  server side scripts, maintaining state information (needed because of page  transitions) in a PDF form using hidden fields, generating FDF files, and  serializing information in a database.	2000-07-10
US	52654201	R1IJCF1UZJ5SJK	0442319460	244913733	Weaving a Program: Literate Programming in Web	Books	4	2	2	N	N	Comprehensive reference for WEB programmers	The mechanics of using the WEB language, the original literate programming system for Pascal, is covered in the first half of the book. The second half of the book contains sample literate programs including weave, tangle,  mtangle, mweave, knight's tour, eight queens, table handler library, and  homotopy. This is an excellent reference for resolving error messages  (chapter 7) or customizing the behavior of your WEB system (chapter 5 &amp;  13).	2000-07-06
US	52654201	RF1ID6PKYVWWQ	0070328110	561365916	Programming Productivity (McGraw-Hill Series in Software Engineering and Technology)	Books	4	5	8	N	N	Effective measurement of software development teams	Examines methods for determining program size and programmer productivity such as lines of code, software science, complexity, function points, and economic results.  Studies the following 20 factors having quantified  impacts on software projects: the programming languages used, program size,  the experience of programmers and design personnel, the novelty of the  requirements, the complexity of the program and its data, the use of  structured programming methods, program class or distribution method,  program type or application area, tools and environmental conditions,  enhancing existing programs and systems, maintaining existing programs and  systems, reusing existing modules and standard designs, program generators,  fourth-generation languages, geographic separation of development  locations, defect potentials and removal methods, documentation,  prototyping before main development begins, project teams and organization  structures, morale and compensation of staff. Discusses the following 25  significant factors having qualitative impact on software projects:  schedule and resource constraints, unpaid overtime, staff size, total  enterprise size, attrition during development, hiring and relocation during  development, business systems and/or strategic planning, user participation  in requirements and design, end-user development, information centers,  development centers, staff training and education, standards and formal  development efforts, canceled projects and software disasters, project  redirections and restarts, project transfers from city to city, response  time and computer facilities, physical facilities and office space,  acquiring and modifying purchased software, internal politics and power  struggles, legal and statutory constraints, U.S. export license  requirements, enterprise polices and practices, measuring productivity and  quality, productivity and quality improvement steps.	2000-05-28
US	52654201	R18WGAG8FXDVZY	0787951730	405018423	The IT Consultant : A Commonsense Framework for Managing the Client Relationship	Books	4	8	9	N	N	Add relationship skills to your technical expertise	This book is designed to help independent consultants or consulting firms improve their client relationship skills. Discusses the stages of a consulting engagement such as understanding the client, approaching the  client, negotiating the relationship, designing solution options, and  delivering business results. Explains the importance of developing superior  consulting skills in areas such as understanding the IT consulting  profession, delivering full value, and improving your skills profile. The  examples and case studies are oriented towards network consulting. The  accompanying CD lacks meaningful content (electronic copies of the  appendices in Microsoft Word format).	2000-05-23
US	52654201	R2A474RA89QVLF	0138217289	732115312	Software Maintenance Guidebook	Books	5	0	0	N	N	classic text on software maintenance	Explains character traits that are ideal for a maintenance programmer such as flexibility, broad background, patience, self-motivation, responsibility, humility, innovation, and historian. Compares and contrasts  the styles used for programming in languages such as assembly, Fortran,  COBOL, and ALGOL. Enumerates tools for software development and proposes a  &quot;supercompiler&quot; and &quot;programmer's workbench&quot;. These  concepts are similar to the modern interactive development environment  (IDE). Excellent discussion of preventing maintenance using techniques such  as modularity, clustering, program structure, data structure,  parameterization, data communication, defensive programming, programming  standards, and documentation. Defines the content and structure of good  internal documentation for use in the maintenance phase of the life cycle.  This outstanding book is still relevant and will remain relevant.	2000-05-15
US	52654201	R38T5L1HQ62PJ9	0201533936	758313661	Scientific and Engineering C++: An Introduction with Advanced Techniques and Examples	Books	5	5	5	N	N	methods for expressing commonality in C++	Enumerates reasons for choosing C++ as an object-oriented programming language for scientific applications. Provides an excellent introduction to C++ concepts for FORTRAN programmers. Gradually explains advanced  techniques such as templates, abstract interfaces, and class hierarchies.  Develops new C++ data types for arrays, matrices, smart pointers, strings,  and Albelian groups. Employs relevant code examples in areas such as finite  element grids, solving systems of equations, GPIB controller, and automated  dimensional analysis. Discusses techniques for creating C++ wrappers for  legacy C and FORTRAN libraries. Concludes with a program for data modeling  that is built from the preceding chapters. The data-modeling chapter  illustrates bottom-up program design.	2000-04-05
US	52654201	RYVI1NY8YVA4O	0201485672	532976631	Refactoring: Improving the Design of Existing Code	Books	5	2	3	N	N	Excellent catalog of source code transformations	Learn how to improve your code using 73 refactorings. Sixty seven percent (49/73) of the refactorings are specific to object-oriented languages such as Java, C++, and Smalltalk. Refactoring promotes a healthy approach to  maintenance programming. &quot;When you find you have to add a feature to a  program, and the program's code is not structured in a convenient way to  add the feature, first refactor the program to make it easy to add the  feature, then add the feature.&quot; Fowler's systematic approach and  insistence on regression tests insures that each refactoring will not break  any existing code. The constant application of appropriate refactoring  results in reliable and clear source code. Some refactorings are opposite  pairs such as &quot;Add parameter&quot;, &quot;Remove parameter&quot; and  &quot;Replace Delegation with Inheritance&quot;, &quot;Replace Inheritance  with Delegation&quot;. A refactoring may have significant downsides, for  example &quot;Preserve Whole Object&quot; increases coupling and  &quot;Replace Temp with Query&quot; decreases performance.	2000-03-17
US	52654201	R3TLPDRKDN84QS	0201100886	252944232	Compilers: Principles, Techniques, and Tools	Books	5	66	68	N	N	Outstanding reference for C, Fortran, and Pascal compilers	During each compiler stage (lexical analysis, syntax analysis, translation, type checking, translation, code generation, and code optimization) multiple methods, strategies, and algorithms are presented.  This comprehensive book examines items that are unique to the various  languages presented (Fortran, C, and Pascal); there are even sections on  dealing with estimation of types (10.12) and symbolic debugging of  optimized code (10.13). Wow! The exercises are thorough, challenging, and  thought provoking.  Examples are interleaved with the discussion and  algorithms. There is an excellent set of historical and bibliographic  information at the end of each chapter. The use of automated tools such as  lex, yacc, and compiler-generators is discussed throughout the text. This  is an advanced book, however a good understanding of compilers can be  obtained without understanding the details of every algorithm.	2000-03-14
US	52654201	R38ZFSACH2RAST	0387982752	836870959	Ethical and Social Issues in the Information Age (Undergraduate Texts in Computer Science)	Books	3	8	8	N	N	A myriad of topics each discussed briefly	Excellent chapters covering morality, law, ethics, professional codes, and intellectual property rights. Provides a basic introduction to many topics that stimulate further study, research, and discussion. Discussion of  social issues is limited. The weaker chapters are the modern areas of the  information age such as cyberspace, the internet, email, privacy, security,  artificial intelligence, and virtual reality.	2000-02-19
US	52654201	R3NC3DIBPP6K62	0201544350	742972750	Object Oriented Software Engineering: A Use Case Driven Approach	Books	5	17	17	N	N	Standard text for object oriented analysis	Lucidly describes the fundamental principals of object-oriented analysis, design, and programming. Excellent coverage of object-oriented analysis including the introduction of use cases. Uses an awkward state transition  graph that resembles a flow chart in the design methodology. Emphasizes  traceability from analysis model to design model to source code.  Describes  how object-oriented technology impacts specialized topics such as real-time  systems, relational databases, testing strategies, component reuse, and  product management. The &quot;warehouse management system&quot; case study  is more stimulating than the longer &quot;telecom&quot; case study.  Compares the OOSE method with other standard object-oriented methods.	2000-01-25
US	52654201	R1UE511EOAETTO	084939001X	157084234	Graphics and GUIs with MATLAB, Second Edition	Books	3	21	22	N	N	GUI programming and user interface properties	Common plotting techniques covers material already presented in the MATLAB manuals. Handle graphics is a great introduction to the MATLAB user interface organization. The properties of user interface objects are  covered comprehensively including the properties not documented by MATLAB.  The author distinguishes between MATLAB 4 and MATLAB 5 features and  programming. Explains stretchable GUIs and interruptible callbacks. The  book needs a deeper coverage of MATLAB programming techniques especially in  the data structures, code organization, and callback techniques. Example  functions use the finite state machine programming style. Good supplement  to the MATLAB user manuals.	2000-01-13
US	52654201	RWCQP520C66Z5	0471176494	654569866	The Computer Consultant's Guide: Real-Life Strategies for Building a Successful Consulting Career	Books	4	7	9	N	N	Practical business advice for consultants	Know when you can start consulting as a sustainable business. Receive a reasonable fee for your services. Be prepared for the pitfalls of operating your own business.  Hear about success stories and business strategies from  practicing computer consultants.  Learn about starting your consulting  business, marketing, contracts, client relationships, and income producing  consulting activities. This book is practical and realistic.  The author  has a negative opinion of Big 5 accounting firms.	2000-01-04
US	52654201	R3BY40YGYDNR0E	0937073814	394816487	Literate Programming (Center for the Study of Language and Information Publication Lecture Notes)	Books	5	10	15	N	N	Articles related to literate programming.	Excellent analysis of control structures in the classic article &quot;Structured Programming with goto Statements.&quot; Invents the literate programming style of program documentation. Convincingly  demonstrates the literate programming style with six example programs.   Includes an independent program criticism and an error log. Highly  recommended.	1999-12-15
US	52654201	R2PBGB06QC4UL0	0137488807	576001953	Applying UML and Patterns	Books	5	10	12	N	N	OOA, OOD, UML, and Patterns	Theory and practice are balanced through the development of a point-of-sale application. Excellent utilization of UML diagrams. Stimulating discussion of class design using the General Responsibility  Assignment Software Patterns (GRASP). Concentrates on domain objects.  Distinguishes between closely related concepts such as conceptual vs.  design model and multi-tiered system architecture vs. deployment  architecture. Decomposes software using iterations, packages, and layers.  Effectively presents object-oriented analysis and design while applying UML  and patterns. Highly recommended.	1999-12-11
