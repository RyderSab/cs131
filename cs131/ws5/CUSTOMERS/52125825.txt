US	52125825	RFMGI86RU0S6B	0130661023	734472032	Computer Networks (4th Edition)	Books	5	40	42	N	N	Clear and Thorough. Engineer's point of view.	Computer Networks are a wide and fastly growing subject. Finding a textbook that covers all of the topics in a detailed way is simply impossible. Perhaps for this reason good textbook authors have, in a probably implicit way, established two possible approaches: the Engineers' and the (mostly Software) Developers'. Once again Tanenbaum has done a great job with this book (and its updated-more-than-revised 4th edition), which takes the former approach.<br />The book presents general issues and impacts (on technology as well on the society) of Computer Networks in the first chapter, and then move in a detailed exposition of the lower layers of a general network architecture (similar to the OSI one). The great value of the books stems from the clarity and thoroughness of the exposition. Indeed, it presents all of the most known technologies and algorithms (both today's and historical) from physical mediums to algorithms for routing, congestion and flow control and so on. Plenty of details are provided at the level of mathematical performance analysis for some algorithms like those presented in the Medium Access Sublayer chapter (e.g. ALOHA and CSMAs).<br />The \\"tone\\" of prof. Tanenbaum is an added values as well. He rarely becomes boring and sometimes results hilarious in his comments of famous anecdotes that led to the born of this technology or that algorithm (have you ever heard how automatic phone calls switching was born ?). I never underestimate the value of an easy exposition, as sometimes studying is already hard enough to cope also with a overwhelmingly boring book.<br />Enough for the lower layers/protocols so far. About the upper ones the book actually does not spend too much emphasis on network applications nor on the high level tools for building network applications (e.g. there are a very few pages for sockets, but no more). Indeed, this area is more properly in the competence of the second kind of books (Developer's) as noted at the beginning of the review. However, there's one (unsurprising but happy) exception: as already done in his \\"Modern Operating Systems, 2e\\", Tanenbaum has put a detailed and rigorous treatment of the Security issue (Network Security in this case).<br />About editions, the third was already a very good book. Reasons for considering the fourth edition are the inclusion of updated technologies like ADSL, Bluetooth, Gigabit Ethernet, JavaScript, XHTML or XML, etc. More than this, however, technologies like fiber optic were on the wave of great improvements in 1996 when the third edition was published (and deformation due to day-night thermal excursions were not cited) so that now the treatment is more reliable (in terms of updates, not in technicalities).<br />All in all, given that imho there's no serious \\"complete bible\\" (or the like) book on computer networks, this book is a full five-stars one if the Engineers' perspective is that of interest. If one is more interested in the Developers' perspective (take again the sockets example), then a good choice would be Douglas Comer's \\"Computer Networks\\". For TCP/IP fans, my best choices would be the more focused Comer's \\"Internetworking with TCP/IP, vol. I\\" (1/3 Engineer's, 2/3 Developers') or Stevens' \\"TCP/IP Illustrated. vol I\\" (1/5 Engineer's, 4/5 Developers').ew. However, there's one (unsurprising but happy) exception: as already done in his \\"Modern Operating Systems, 2e\\", Tanenbaum has put a detailed and rigorous treatment of the Security issue (Network Security in this case).<br />About editions, the third was already a very good book. Reasons for considering the fourth edition are the inclusion of updated technologies like ADSL, Bluetooth, Gigabit Ethernet, JavaScript, XHTML or XML, etc. More than this, however, technologies like fiber optic were on the wave of great improvements in 1996 when the third edition was published (and deformation due to day-night thermal excursions were not cited) so that now the treatment is more reliable (in terms of updates, not in technicalities).<br />All in all, given that imho there's no serious \\"complete bible\\" (or the like) book on computer networks, this book is a full five-stars one if the Engineers' perspective is that of interest. If one is more interested in the Developers' perspective (take again the sockets example), then a good choice would be Douglas Comer's \\"Computer Networks\\". For TCP/IP fans, my best choices would be the more focused Comer's \\"Internetworking with TCP/IP, vol. I\\" (1/3 Engineer's, 2/3 Developers') or Stevens' \\"TCP/IP Illustrated. vol I\\" (1/5 Engineer's, 4/5 Developers').	2003-02-14
US	52125825	RXSP9MPTEGY5Q	1558604286	721748420	Computer Organization and Design: The Hardware/Software Interface	Books	5	4	5	N	N	Quite unconventional, quite useful	This book is quite a strange case. For sure, it is the most widely used around the world for intro courses on Computer Architecturs (CAs). Could it be because Hennessy and Patterson are, at present and since a long time, two of the most prominent researchers in the field, Hennessy being now also President of Stanford University, Patterson a professor at Berkeley. But it would be too reductive to limit the view to this only. So we should move inside the book and try to understand the real (or other) reasons.<br />As an introductory text on CA, the approach is different than the somewhat classical one. <br />Those who'd expect a few introductory chapters on logic design (as, e.g., Mano &amp; Kime's chapters or Murdocca's long appendixes) will find instead a short appendix that describes basic components (gates, registers, clocks and so on) at a high level (never mention digital abstracion &amp; co.).<br />The path then is not a survey of general concepts &amp; principles of CA with eventually some real examples as application. Instead, the process is a strictly step-by-step constructive one: they build from scratch a new system funding the design with plenty of considerations and tips, even with warnings on most common &quot;fallacies and pitfalls&quot;.  All this done through a  very straightforward and clear language and with lots of figures, well paced and presented. As a result, coping with the topics is pretty an easy task, and the most likely result is a thourough understanding of what they present.<br />So what they present ? Substantially, the MIPS, a well known (thanks to this book and their authors too, of course) and widely sold (thanks to its true qualities) RISC processor. The authors have been leaders in the development of the RISC architecture, which admittedly is by now the only good choice for CPU designs since even Intel in its newest architectures reduce all down to the execution of RISC instructions. Anyway, the attention is not only on RISC (and MIPS) architectures: it's &quot;mostly&quot; on these, but there's space for short disgressions in the PowerPC, 80x86 and Pentium Pro (the book is dated 1997) field. This is done through a section named &quot;Real stuff&quot; in each chapter, where after they've extensively developed the subpart of the MIPS (be it the ISA, the ALU or Datapath &amp; Control, the Pipeline and so on), they summarily look at how the same concepts have been developed by PowerPC and 80x86 or Pentium.<br />All in all, if the book has been assigned as a textbook for a course, little integration is needed to understand it and made it useful for the course; or if it is used a self first introduction to computer architectures and especially RISC architecture, the book will prove a very good choice. And this happens simply because the transfer of knowledge is effective as probably the authors have intended it to be.<BR>If what is needed is a reference, then perhaps the step-by-step approach would suggest other choices (e.g. Tanenbaum, Murdocca, Stallings or Mano &amp; Kime).	2002-07-29
US	52125825	R3AXW48MYHDBYS	1558605967	826479956	Computer Architecture: A Quantitative Approach, 3rd Edition	Books	5	29	34	N	N	The milestone and its third edition	First, this is certainly not an introductory text on Computer Architectures. The authors assume that people reading it have already had an introductory class or some experience. Simply put, the book is not intended to explain how cache memory works, but to present a thourough quantitative analysis to show why and when one implementation works better than another, and what improvements have been devised recently to speed this or this other measurement.<BR>Of course, the best choice for this book would be to have it preceeded by &quot;Computer Organization: the HW/SW interface&quot; (aka CO-HSI), by the same authors, since it would help to better comprehend the MIPS64 and the low-level design behind it, since CO-HSI develop an older version of the MIPS itself.<br />This is for sure one of the most informative books I've ever encountered both as a student and as a SW engineer. It contains an overwhelming quantity of data, tips, warnings, tecniques so that the over 1100 pages seem incredibly dense. And don't be fooled the book is &quot;only so little&quot;: there are other seven online appendixes that can be downloaded, that will add up to more than 250 pages to the book.<BR>As experience teaches, however, quantity does not always mean quality. Yet, it seems this doesn't apply to this book, because the quality of its content is highly informative and interesting for those involved with true CA designs.<br />Since the first chapter it's clear that target of the book is not a survery of CAs, but a guide through the bunch of considerations and problems a design of a new CA must cope with today. I mean today because much of the data collected and presented is binded to (and updated to) the current edition and its realease date. So covered CAs for this 3ed will feature IA-64 or Sony Playstation II among the others. Nonetheless, it would be misleading to think that next year the book will become useless. Most of the considerations the authors develop and present are quite long lasting (the usage patterns of ISAs, e.g., have incurred little change since the second edition, six years ago).<br />This edition presents noticeable changes, even if there's no doubt the core is that of CA-AQA 2ed. To mention a few, the first chapter is of course almost totally new since it's the most time-bounded of the book. The elder chapter four (Advanced Pipelining and Instruction Level Parallellism) has been expanded into two chapters, one dealing with Hardware approaches and one with Software approaches (and both with hybrid ones). This goes into great benefit for the reader since it seems we never get enough details on modern CAs and their complexity otherwise.<BR>However, changes has been done even in the way of reductions, and that's especially true for the elder chapter three (Pipelining). It was a full 100 pages chapter, featuring an astonishing treatment of the topic, that has been fundamental in my class of CA II. In the 3ed edition, this chapter has been moved to a shorter appendix at the end, and I think this appendix can't compare with its predecessor (even if some of the &quot;cut&quot; topics have been then spread through chapters 3-4 in the 3ed).<br />About the exposition of the topics, the authors have built a solid way to make things clear for students and not, beginners and not on quantitative analysis. The book is full of figures, graph, citation and feature a wide bibliography at the end of the book and a reasoned set of references at the end of each chapter.<br />The only difficulties reading this book will arise only because of the complexity of the topics, who themselves require a fair amount of attention, not because of the language which keeps always clear and straightforward.<br />This said, I think the book is a fully deserved 5 stars one, with no concurrents on its kind, scope and utility. That's probabily why it has been worlwide used since its first edition.	2002-07-29
US	52125825	R2DW4H6SXKK36D	0201000296	907388542	The Design and Analysis of Computer Algorithms	Books	5	46	53	N	N	The very classic	Excluding Knuth's opera (another dimension), this (AHU) is about the other and only renowned classic algorithms book, deseverdly I'd say, together with Cormen-Leiserson-Rivest's (CLR) &quot;Introduction to Algorithms&quot;. With the difference that the first and only edition of AHU has been written 16 years before the first (of the two) editions of CLR.<br />The two books are quite different in the language and formalism used: more formal and mathematical inclined AHU with respect to CLR. I'd say, the very classic style of his authors who have made history in the CS literature with their books (particularly 2 on algorithms and data structures, 2 on Computer Theory, 2 on Compilers, 1 on CS foundations): as these books have been used in most universities around the world for decades, they've proved to be real milestones in the education of thousands of students.<br />The books differ also in scope, since AHU is certainly not an encyclopedic collection as CLR does, with his roughly 500 pages against 1000. In spite of this, I'd point out the following: my textbook on Algorithms was CLR, but when we got to Complexity Classes (P-NP and theory behind) we &quot;had&quot; to switch to AHU for the simple reason that CLR did not almost mention at all Turing Machines nor Space Complexity, without which is certainly possible to learn e.g. about NP-TIME completeness, but without which, such a path would equally certainly miss some foundamental topics of Complexity Theory.<br />All in all, then, imo the book truly deserves 5 stars (and perhaps it would deserve a second, updated, edition too ... possibly, imho, through a bit less revolutionary revision job than they did with &quot;Introduction to Automata Theory, Language and Computation&quot;).<br />As a final note, those looking for a more applicative and self-reference than an educational introductory text, could have a look at the two-volumes opera by the former Knuth's pupil, Robert Sedgewick (possibly the more consolidated Cor C++ versions).	2002-07-16
US	52125825	R3QVORR67DPF35	0486402584	168904928	Combinatorial Optimization: Algorithms and Complexity (Dover Books on Computer Science)	Books	5	21	21	N	Y	It worths exponentially much more than its price	One could buy this book for different reasons: interests in combinatorial optimization, of course; interests in what Papadimitriou has to say, since his thoughts on this subject are definitely invaluable; perhaps the price is a good reason alone.<br />Whatever the reason, however, I think that would be a rare event to remain duped.<br />I was preparing my exam in Computability and Complexity when I first used it. I've been wonderfully surprised by the amount of definitions, algorithms, concepts I've found in this book. I think one could use this book for a simple course on Algorithms, on Computability and/or Complexity, on the whole Combinatorial Optimization, and the book would be always and costantly useful.<br />The chapters on algorithms and complexity, or those on NP completeness have proved to be gems. The chapters on Approximation and Local Search are great, and they feature a bunch of detailed and excellent quality stuff (e.g. there is a detailed treatment of Christofides' algorithm to approximate the TSP, that is quite an idiosyncratic topic).<br />All in all, a very great book, with a value exponentially greater than the very insignificant price.	2002-06-21
US	52125825	R28EPXG9H1OT4H	0201100886	252944232	Compilers: Principles, Techniques, and Tools	Books	5	102	112	N	N	The reference book ... depending on your needs	Once again, I want to point out the title of the book: &quot;Principles, Techniques and Tools&quot;.<BR>I think there are two kinds of compilers books available today: &quot;Principles and Theory centered&quot; ones and &quot;Modern Compilers design and implementation&quot; ones.<BR>One might wonder what's the difference between the two. <br />The former kind is more suited for a course on theoretical aspects that lay the foundation of compiler construction. DFAs, NFAs and Regular expression along with relations and equivalence between the them; FSAs minimizations; grammars and Push-down FSAs in details, ambiguities and and how to cope with them; and so on.<BR>This is what I mean for &quot;theoretical aspects&quot;. And these topics are covered in great details in this book. Almost the same details they (the authors) placed on writing a more specific book as &quot;Introduction to Automata Theory ...&quot;.<BR>Same situation applies to principles on more application- oriented topics. Take the example of LR parsing. You can face the topic from a more theoretical side, dealing with details on bottom up parsing (still, it implies an in-depth knowledge of grammars theory), handles and (viable) prefixes, SLR or canonical LR or LALR parsers and techniques for the relative tables construction by hands (and for this, add a detailed and solid knowledge of Push-down FSAs along with grammars). By hands, at least, if principles are what matter in your course. <BR>If you expect to find these topics (with this depth) in a book of the other kind, you might get mislead. As I did when I still had not clear this distinction, before I took the course.<br />The latter kind of books is more suited for a more pragmatic course. One where real, &quot;modern&quot; compilers are at hands, and probably written as homeworks. In this case, time being always limited in a university course, one (the instructor) will likely have to give up with those theoretical aspects (or just mention them) and focus on coding techniques and modern compiler studying.  But ... perhaps, for these purposes books like Grune's &quot;Modern Compiler Design&quot;, or Pittman's &quot;Art of Compiler Design, The: Theory and Practice&quot; or, at some degrees, Muchnick's &quot;Advanced Compiler Design and Implementation&quot; will be more suited.<BR>Back to the LR parsing example, more pragmatic compilers design courses will (for time constraints) just have a glance on principles and spend a considerable time learning YACC. To do both things you would have to take a course on YACC alone (it requires time to exploit all of its advanced features, you can be sure of this).<br />All this said, once again: which is the best book ? The one that best fits your needs. And in fact, my needs were those of my course, which was completely centered on theoretical aspects. And for this course, the Dragon book (as it is better known since its cover) proved to be perfect, definitely no matter it was published on 1986: FSAs and grammars and their theory is (for all practical purposes) still the same since even before then.	2002-04-19
US	52125825	R2V72DE7FFOO7U	0716782618	978754304	Introduction to Compiler Construction	Books	5	31	31	N	N	Intelligent book	I think Parsons had an intelligent idea in writing this book. Without originality claims (as he point out in the preface) the book is intended to the audience of novices, with the clear target of explaining in great details compilers principles. As he says in the preface, the objective is to prepare the reader for more advanced lectures, and he explicitly mention the reference book as an example: Aho-Sethi-Ullman's &quot;Compilers: Principles, Techniques and Tools&quot;, a.k.a the Dragon book.<br />The approach is quite theoretical and principles-centered, just as the Dragon book is. But Parsons departs from this in the writing style: It is definitely straightforward. He sacrifices the scope of the book in favor of clarity: he took the core of books like the Dragon, and expanded this core to a well appreaciable extent. It comes over and over again on more awkward concepts with detailed examples.<BR>Reading the Dragon is not extremely difficult, but requires time. No question that doing it after Parsons' is another thing, absolutely. In this, he succeeded perfectly in its objective.<br />The price is definitely not exaggerated (especially for the paperback version), and adding this to the book's quality, should not let think twice in buying it.	2002-04-19
US	52125825	R2QTFZGYL2VAHA	0201924889	971698755	Effective C++: 50 Specific Ways to Improve Your Programs and Design (2nd Edition) (Addison-Wesley Professional Computing Series)	Books	5	1	1	N	N	Great value book	This has been my first C++ book after Stroustrup's. <BR>After reading it I can say that much of the stuff in this book can also be found on Stroustrup's. What is the added value of this book then ?<BR>Objectively, it brings some techniques that you may encounter for the first time here, and that once learned they use to become bread & butter of everyday programming. Think about the body/handle or letter/envelope patterns. You can learn them from Coplien's, from Gang of Four's \\"Design Pattern\\" or elsewhere. However Meyers' account on these topics is truly straightforward and expanded (respect to Coplien's, e.g.).<BR>But there's more. A single read of a big manual (e.g. Stroustrup or Lippman or Deitels) will often result as not enough impressing to the novice, especially if the read has been a fast one (\\"we need that you learn C++ as soon as possible ...\\"). Too many details could pass unobserved; hence a second, slower read would be a good idea. But reading such a manual twice, from the first to the last page, is something that require a fair amount of courage. It's at this point that books like this and others (always the company: Coplien, Meyers, Murrai, Allison, Koenig and so on) show their usefulness: they make you ponder about those details you've missed but that are really important if you want to exploit the language as a good accustomed user does.<BR>Why this book instead of some others of the same kind ? Simply because it's very clearly written and easily readable. I've had absolutely no difficulties in reading it, item after item. Meyers has a good and often entertaing writing style, and more important he very well knows the language. I'd say: one of the best source to improve your language knowledge from.	2002-03-26
US	52125825	R3BSAV97X4MYA4	020163371X	420320077	More Effective C++: 35 New Ways to Improve Your Programs and Designs	Books	5	7	7	N	N	More valuable than the first volume, if possible	After being a very satisfied reader of the first volume, I bought this second as well. And I'm even more satisfied with this book. There are fewer items than the first volume, but I found they are exactly those items you're looking for after reading a C++ big manual and the first Meyers' book.<br />The section on exceptions is a very appreciable collection on exceptions topics, difficult to find elsewhere, unless you're a constant reader of C++ Report (where they held a monthly column on the subject).<br />The section on efficiency is a niece and useful read that let you meet some important consideration as the famous 80-20 rule (a.k.a. 90-10 rule, the &quot;make the common case faster&quot; pattern, and so on) or the Lazy Evaluation tecnique (I've used it extensively since I'm involved on big proportions projects that need this kind of savings).<BR>A special mention goes on the item about the costs of virtual functions, polymorphism and RTTI features. This is about the best account I've found on the subject. The only other one I can think about is Dattatri's in &quot;C++: Effective Object-Oriented Software Construction&quot;. You won't believe it, but I've red Dattatri's just a week before I've been specifically asked for this very same topic during an important job interview. Luckily.<br />The section on Techniques is a source of pure gems: item after item I've discovered how well and widely these topics can be treated. Some will find they are taken from Coplien's book. And that's true. But here they are expanded and more clearly explained.<br />The last section also will bring some knowledge that will prove to be useful whenever you'll be involved in software design. They well add to those on the first volume.<br />A very worth buying, and a very worth read, on my opinion.	2002-03-26
US	52125825	R39Y14KIEEJ6GJ	0201889544	298626172	The C++ Programming Language (3rd Edition)	Books	5	6	7	N	N	The best source of knowledge on C++	I've learned C++ from this book first, a few years ago, so my experience is the that of a novice.<BR>On the writing style, I agree with those who say that it could have been written in a clearer way. The reading sometime had to proceed slowly, and sometime turn back a few pages and restart.<BR>On the content, instead, I think that no other book brings the same knowledge in both quantity and quality.<BR>It comes as no surprise that being Stroustrup the first inventor of C++, few people knows it better than him. Through this thousand of pages it is possible to learn plenty and plenty of details about the language. But should is stop here, it would be just another Kernigan &amp; Ritchie. Indeed, the book brings much more. The language is explained through the use of a lot of examples that in reality are true insights on programming techniques. Perhaps you'll follow the classic path of buying this or some other big reference on C++, and then some other lighter book on tecniques and/or coding strategies. I did it, passing through exceptional books (Coplien, Koeing, Meyers). Now, looking back, I realize that much of the stuff I've learned through these latter books, could have been learned through Stroustrup's as well. All this stuff is there. The problem is that you learn them together with the language and the OO notions, so if you are a novice they could not receive the deserved attention (and perhaps they don't have the deserved space in the book. But, after all, I find they are &quot;add-in&quot;s, not the main subject).<BR>And there's still something more. Through the chapter Stroustrup exposes his view on the OO subject. It's a personal view (that lead to the language development as a support), but it's a good one, on my opinion. One that, among the many, deserves respect and that can get a direct match on the most widely used language, together with C.	2002-03-25
US	52125825	R2SIHGLUOFL6A	0130555312	648587661	Logic and Computer Design Fundamentals and Xilinx 4.2i  Package (2nd Edition)	Books	4	7	9	N	N	Good intro	This book is well suited for a namesake semester course. We have used it, together with Murdocca's &quot;Principles of Computer Architecture&quot;. The result has been quite satisfying for all of us. The book is well paced, and digital design topics are covered just enough to understand the second part of the book, about computer design fundamentals. This second part too is very well explained and many subtleties (e.g. details on CISC and RISC kind architectures) are precisely pointed out.<BR>My only complain is that design concepts are explained with no reference to real CPUs (e.g. Intel, SPARC, Motorola, PowerPC), so if you are the kind of reader that likes a direct match on reality you'll have to look elsewhere to find some examples (e.g. Murdocca).	2002-03-25
US	52125825	R2J122XQS103P0	0136299814	175450385	Object Oriented Analysis (2nd Edition) (Yourdon Press Computing Series)	Books	4	3	4	N	N	A Classic	This book is one of the classics on the subject. Coad and Yourdon have been among the pioneers on OO methodologies, and their one is a well respected account.<BR>What they provide is a complete methodology that covers all the software engineering phases, from analysis (with this book) to implementation (their OOP book).<BR>You'll find that specialized magazines routinely presents articles that compares various methodologies. In each of them you'll always find Coad-Yourdon one. For this reason, despite the book is a bit old-dated, it worths a read and, indeed, it can be easily red. You'll gain a better understanding of the modern OO literature, and some insights that are timeless.	2002-03-25
US	52125825	R1IEJ37VZYBU55	0201548550	667504788	Advanced C++ Programming Styles and Idioms	Books	5	14	15	N	N	Well worth many reads, even if 11 years old	Coplien has won many consensus thanks to this book and his \\"Multi-paradigm design\\". You can easily verify it looking at the bibliography of EVERY book on C++ written after 1991: you'll certainly find \\"Advanced C++ Programming Styles and Idioms\\". Many books have used it to expose tecniques. The best examples are both Meyers' \\"Effective\\" and \\"More effective\\" books. You can jump directly to the Recommended Readings sections to read the right acknowledgment to Coplien's book. You can then browse the items, and discover that some of them are revisitations and expansions of Coplien's ones). <br />Reading this book completely changed my view of C++, and, indeed, of any programming language. It traces a clear path that lead from a \\"normal\\" use of the language to a well-conscious use of each of his potentialities (those available in 1991, at least). Just look at the functors section to understand what a gem is this book, this is one of the most mind-expanding examples of the book. And if you did not understand what ADT are before, you'll gain a fine and solid account here. This just to quote a couple of examples.<br />Eleven years are a lot, and the language have undergone major expansions, especially since the ANSI draft on 1996-97. However, this doesn't take anything away from the value of the book, after all you can always learn namespaces from any other modern book. It's not a case that this is one of the most quoted books in the C++ literature.<br />Many have said it, and I can only confirm that this book should have a stable place on each C++ developer's bookshelf (together with Stroustrup, Meyers, Koeing, Allison and Murray).	2002-03-25
US	52125825	ROAR6LJZRPNRN	0136291554	618603318	Object-Oriented Software Construction (Book/CD-ROM) (2nd Edition)	Books	5	9	10	N	N	Probably the best book on OO	Those who have red a fair amount of stuff on OO methodologies, languages and technologies will have learned that ... no such thing as a standard OO methodology or language or technology exists. Every books author, programming languages inventor or methodologies designer gives a different definition of even the most common concepts you'll find in every book or article. Thus, the best one can do is to read as much as he can, and try to build his personal view of what OO means and brings. The literature, after all, is full of references, it's up to each of us to find the time to read them.<BR>In pursuing the objective to read the best available sources, this OOSC2 deserves a special mention. It has several qualities that put it aparts from the pool.<BR>First, it's complete. I mean, it could be your first book on OO and you would be gently but rigorously introduced to all the concepts you &quot;should&quot; (in &quot;my&quot; view) learn.<BR>Second, it teaches an OO programming language, i.e. Eiffel. And this is good both because learning a programming language will give you the concrete sensation of one important application of OO technologies, and because Eiffel has been invented by Dr. Meyer itself, so it's supposed that none can teach it better than him.<BR>Third, in addition to OO technologies you'll learn another product of Dr. Meyer's mind: Design by Contract. I know, this is finely interwined with both OO techno and Eiffel that it doesn't seems &quot;really added&quot;, but part of them. True, but you would have to buy another separate book (by Dr. Meyer itself) should you ever been interested only on it.<br />This said, from this book you'll gain a solid introduction and very likely a thourough understanding of OO technologies and of one widely famous OO programming language. That is: a good investment, both for your wallet and your time.	2002-03-25
US	52125825	R2APOS5MKBAZ5C	0716782847	251758230	Foundations of Computer Science: C Edition (Principles of Computer Science Series)	Books	5	11	12	N	N	An always useful reference	I've used this book for the namesake course at university, 2 years ago. It proved to be perfectly adequate at that time. It was very readable and complete. And this would be enough for me to give it a five stars rate.<BR>But there's more. After these two years I've collected many other books in various areas of CS, but when I need a quick reference on any specific topic or I don't remember the formal definition of a concept, I always find this book in my hands. It is one of the references I use most often.<BR>It has been my first book by the couple Aho-Ullman. Now I've understood that whenever these two &quot;emeritus guys&quot; writes something, it always worths time and money to read them.	2002-03-14
US	52125825	R1LHOGWBIUIU4V	0262032937	724287306	Introduction to Algorithms, Second Edition	Books	4	9	10	N	N	Still &quot;the&quot; reference, still errors	The book is, as long as I know, the standard for introductive algorithms courses. And one can easily understand why, since it is complete and authoritative. An encyclopedic good work that deserves respect and a good reviews.<BR>I'd gladly give a five stars rate, but it seems that this book must chronically suffer the annoying disease of bugs and printing errors. It was so in the first edition and it seems it is going exactly the same way in this second edition. Just go to the MIT Press web site and check the impressive (since we are just at the sixth month of life ...) bug reports list.	2002-03-14
US	52125825	R2251AG7INJE3M	0471332364	533589112	Extended , Fundamentals of Physics, 6th Edition	Books	3	42	48	N	N	Good but shallow intro	I've done extensive usage of this book lately together with Sears and Zemansky's &quot;University Physics&quot;. So it has been natural to me to compare the books while using them day by day.<BR>The result has been quite disappointing for me, regarding Halliday's book. <BR>The book is very clear and well illustrated, and can be successfully used as an easy intro to the subject. It is also complete since you'll find all of the classical and modern Physics topics.<BR>But ... but unfortunately in this case easy has meant shallow to me, since it often happened that for a given topic, concepts were given &quot;as they were&quot;, with no explanation of the why or how scientists arrived to a given formulation or result. Take the case of Simple Harmonic Motion: x = Acos(wt+f). Although this formula presents no difficulties to me, I wonder where it does come from, how we (humans) first arrived to this conclusion. I had to read Sears and Zemansky to learn that the experiment that lead to this kind of formula includes a simple form of phasors.<BR>The approaches sounds quite different to me: Halliday says &quot;Take it for granted, be faithful&quot;, Sears and Zemansky say &quot;This is the proper kind of formula, and you can see why by yourself if you do ...&quot;.<BR>This is important to me, since I use to block myself on a concept until I fully understand it.<BR>Another drawback of this book is the quantity of problems at the end of the chapter. In my humble opinion, an average of 65-70 problems are too few (considering you have the solutions of only half of them, i.e. the odd numbered ones).<BR>So, this is my conclusion: easy and complete introduction to Physics, but too shallow to be really useful in a university course.	2002-03-07
US	52125825	RLZ9N5OG1BZ0N	0201603365	577023304	Sears and Zemansky's University Physics With Modern Physics (Addison-Wesley Series in Physics)	Books	5	16	17	N	N	The perfect book for a general course	I've used both this book and Halliday's Extended 6th edition for my course on Physics. My conclusion, chapter after chapter, has been clear to me: this is the perfect book for a general course on Physics at university level. The language is simple to understand (Halliday too), the figures and tables are well done and useful (Halliday too), the content is thorough (Halliday: not so much !). Yes, this last is the striking thing: it's thorough and reaches a level of detail that is not a common feature for these kind of Physics books. <BR>The problems set is well balanced both in content and number (an average of 85-90 for each chapter), and as usual odd-numbered problems' solutions are provided.<BR>I've tried this book without anybody advising it to me, now I'm happy I've had it for the exam.	2002-03-04
US	52125825	R1KTII9WSZA75Q	0122063821	333653527	Computability, Complexity, and Languages, Second Edition: Fundamentals of Theoretical Computer Science (Computer Science and Scientific Computing)	Books	5	30	32	N	N	Pure mathematical view of Computability and Complexity	This is not a common book on Computability and Complexity as Hopcroft-Ullman, Sipser or Papadimitrou. You won't find here too many words describing topics: you'll find the power and elegance of a superlative mathematical approach from one the best authors of the century in the field. Conversely, you'll find here a detailed and elegant treatment of the whole history of computational models that starts at the Primitive Recursive Functions, something you won't find in the other books above mentioned.<br />A special note goes to the chapter on Blum's complexity, which is about the only good place where I found it and from where I studied for my course on Complexity I.<br />For this reason the book requires quite more attention than others, but it really worths all the time one can spend reading it. Truly understanding Computability and Complexity as Professor Davis teaches them with this book is in my opinion a definitely high achievement, bringing the sensation that you grasp it totally, with no space for ambiguity or weakness.	2002-02-14
US	52125825	R3D42HB0R9IAZH	0471137723	781181940	Introduction to Computer Theory	Books	4	11	15	N	N	Discursive presentation. Helpful for novices.	The book has one important attribute: it's clear, undoubtedly. Having a minimum of prerequisites, I think there's no way to not understand what Prof. Cohen says through its pages. It makes the job of learning this part of theory easier than any other text.<BR>But ... but I can't totally agree with Cohen's crusade against formalism. I agree that the first target of a book should be to clearly transmit the intended knowledge, and Cohen perfectly succeeds in this. But formalism too has its importance, thereafter. A compact and clear formalism helps to communicate efficiently, and moreover unambiguously. Like in mathematics, the first, important thing is to understand. Yet, there's no way for you to efficiently work with math without using any kind of formalism, should it be more or less \\"standard\\".<BR>That's it: a very powerful book for a \\"profound\\" understanding of the subject; a bit more of natural formalism would make it a \\"complete\\" understanding also, and the book a five stars one.	2002-02-12
US	52125825	RWWA22NSTE7UM	0684818620	540715099	CYBERPUNK: Outlaws and Hackers on the Computer Frontier, Revised	Books	5	0	0	N	Y	True entertainment	I bought this book because I was interested in human aspects of these stories (RTM especially), more than the technical side. I found it very satisfying, and more. I could have not imagined it is so detailed and even ... entertaining.<br />Reading this book I've felt again that nice atmosphere I first met while reading the superlative Cliff Stoll's \\"The Cuckoo's Egg\\". Indeed, those of you who have luckily read it too, will find Stoll himself here in an important role in the chapter about RTM...	2002-02-07
US	52125825	R1SCFCKKJVJZ2Z	0387949070	730453603	Automata and Computability (Undergraduate Texts in Computer Science)	Books	5	19	19	N	N	Definitely an excellent book	This book has been a great surprise to me. Initially I thought that in about 300 pages (excluding homeworks and exercises) I could not find all I could need for an Automata, Languages and Computation course. I was wrong, definitely. The book is coincise, but also rich and precise. <br />The material is very well chosen, and the writing stile is directly thought with students in mind. Kozen has a pluri-annual experience in teaching at Cornell University, and it seems he has developed an effective style of communication with students, that's perfectly reflected in his books.<br />Some important topics are present in this book and not in both Sipser and Hopcroft-Ullman. If you need (as I did) to learn about Myhill-Nerode Relations and Theorem, this book features the best account I've seen (the other, much shorter, reference can be found in the first editon of Hopcroft-Ullman but not in the second one !).<BR>A nice shot of the Lambda-calculus is also featured, and this too lacks in the other two books.<br />The organization in lectures is a very good idea when studying. Lectures are carefully cut and self-contained, so that you can organize your time using this unit, and wherever you choose to stop a study session, you always stop at correct boundary of a topics.<br />As a further (and important) note, the notation used is very clear and elegant. As soon as you get used with it (very soon since its clarity) it becomes very stimulating. Don't understimate this value, since many books feature too-hard-to-follow notations, or no notation at all. Both of which cases are to be avoided, INMH.<br />I have used other books for my course, starting from both the editions of the Hopcroft and Ullman, but one way or the other I found myself always with this book (and Sipser's) in my hands.	2002-02-05
US	52125825	R3SIT7P3SK1EME	0201441241	102051023	Introduction to Automata Theory, Languages, and Computation (2nd Edition)	Books	5	34	35	N	N	Thoughts on this second edition	I've just passed my exam on Theory of Computation, and I've used both editions of this text. Frankly speaking, I couldn't choose one of the two should I keep only one of them.<br />Whereas the first was full of strict formalism, the second has traded this for a more discursive approach. Whereas the first reported theorems name (of their authors), the second has traded this for a richer bibliography at the end of the chapters. And more objectively, the first edition covered more \\"classical\\" topics with shorter treatments than the second, but this last treats survived topics with richer details (starting from the first chapter on mathematical basis for the course) and with updated examples of applications (XML and Markup Languages, e-commerce for DFA, etc).<br />This said, you know why I can't decide. A discursive approach is of course always desiderable, especially if you're completely new to a subject, but a strong notation is helpful in my mind because it improves communication and removes ambiguities. Hence, the best approach would probably have been a mix of the two, or halfway the two.<br />As a second matter, having a rich bibliography is surely helpful both for further studies and as a reference, but it's quite tedious to look at the index and be unable to find something like \\"Kleene theorem\\": you've to dive into bibligraphy to discover that \\"L is an L(DFA) if and only if it also is L(REG)\\" is something that has been studied by Kleene.<br />Finally, I surely can't question the removal of the complexity theory part since it is in the right of the authors to remove \\"optional topics\\" (if you use the book for a course on Theory of Computation only) and give a more focused target to the book, but removing stuff like the Myhill-Nerode theorem make things annoying since virtually every course on Automata theory and Computation includes it (like my one did, as well as the course on Languages and Compilers), so you have to look for it elsewhere if your only one book is this second edition.<br />I would give four stars, should I keep in heavy account the radical changes they made over the first edition and that includes the removal of some stuff, important on my opinion. But ... this is just my opinion, and since it is a very well written and informative book (rich of many details that other texts lack of) and surely one of the bests in the area (I've had 4-5 books in my hands for this course), that's why I gave it 5 stars.cond edition.<br />I would give four stars, should I keep in heavy account the radical changes they made over the first edition and that includes the removal of some stuff, important on my opinion. But ... this is just my opinion, and since it is a very well written and informative book (rich of many details that other texts lack of) and surely one of the bests in the area (I've had 4-5 books in my hands for this course), that's why I gave it 5 stars.	2002-02-05
US	52125825	R3YJGWPB8M29N	053494728X	254036315	Introduction to the Theory of Computation	Books	5	14	15	N	N	Great book	Michael Sipser has an undoubted gift for writing on this subject. The book is a coincise and easy read. But be cautious, this doesn't mean superficial and poor. The book contains all the material needed for a good course on Theory of Computation and Complexity. Perhaps it has not plenty of details like other books as Hopcroft & Ullman or Kozen or Papadimitrou, but don't underestimate the vastity of the treated topics, what is important is that every time you finish a chapter, you have the sensation that you've learned what you should have to. And probably you did due to Sipser's writing style, provided that you can afford to skip \\"some\\" more detailed/advanced topics. Or you might just be looking for some further stuff like Myhill-Nerode or Rabin-Shepherdson theorems or Chomsky Hierarchy for example, and you would have to look elsewhere for them. However, I've never been told that the best book is the most complete one. As long as I've learned, the best book is the one that best fits your needs, and that fitting these needs it suceeds to transmit the knowledge you're looking for in an effective way. That's why if this stuff is not required by your course, you would be perfectly fine with this book in your hands.<br />Proofs on theorems are given virtually always in two steps: first you're presented with the idea that lies behind the proof, and then you get the proof itself in a more rigorous fashion. Again, Sipser strikes here because it's harder NOT to understand one of his proofs than the contrary simply because the presentation is always clear and understandable.<br />As a matter of fact, Sipser (as he point out in the preface) almost always avoid to overload proofs given by construction with more rigorous following proofs (e.g. induction on the constructed machine to prove its equivalence with ...). This has a strong impact on the attention you can keep when studying throghout a chapter: avoiding to dive into tedious details when the proof (by construction) has been clear enough help to keep you attention high and boredom away. This is a way of learning, an effective way.<br />Sipser uses sometime a notation that's different from the somewhat standard one (e.g. the description of delta or transition function on various machines), but it is coherent throughout the whole book, and that's what does count, together with the note that this notation is noway more complex or hard to understand than the \\"standard\\" one.<br />Should I name two books on Theory of Computation (not Complexity), one just a little less rigorous and one just a little more rigorous than this, I would suggest Coehn's \\"Introduction to computer Theory\\" and Kozen's \\"Automata and Computability\\" respectively.<br />My conclusion is that this is a great book, worth the price (especially if confronted with others ...) and a stable place in my bookshelf.n clear enough help to keep you attention high and boredom away. This is a way of learning, an effective way.<br />Sipser uses sometime a notation that's different from the somewhat standard one (e.g. the description of delta or transition function on various machines), but it is coherent throughout the whole book, and that's what does count, together with the note that this notation is noway more complex or hard to understand than the \\"standard\\" one.<br />Should I name two books on Theory of Computation (not Complexity), one just a little less rigorous and one just a little more rigorous than this, I would suggest Coehn's \\"Introduction to computer Theory\\" and Kozen's \\"Automata and Computability\\" respectively.<br />My conclusion is that this is a great book, worth the price (especially if confronted with others ...) and a stable place in my bookshelf.	2002-02-05
US	52125825	R10SO4U754RLGF	0130313580	758567343	Modern Operating Systems (2nd Edition) (GOAL Series)	Books	5	3	4	N	N	The choice for a general OS course	I had in my hands the first edition of this book and I can assure that this second edition is a big improvement: now it really is &quot;modern&quot;. The book covers all of the theoretical aspects of a modern OS, but some chapters are real gems. For example, the chapter on security is a little 100 pages book inside a book. Tanenbaum has a gift for explaining and entertaining, and sometime make you ponder about evolutions of technologies, influences on society and other points like these that helps you to &quot;have a break&quot; when studying has started many hours before.	2001-10-29
US	52125825	R2AS9EIJBDIXF3	0262231395	381817313	Computation Structures (MIT Electrical Engineering and Computer Science)	Books	5	21	21	N	Y	Timeless concepts	This book is quite idiosyncratic in its kind. The content is quite theoretic, so that probably it won't be the best choice for more pragmatic and practice-oriented courses, for which the two books from Patterson-Hennessy, e.g., will be more suited. However, the value of this book lays in the shocking amount of knowledge it carries. This is the classic gap-filling book: my opinion is that many CS student of us that will read this book page by page, will discover that they really didn't know something they thought they knew instead. This is simply because the discussion is organic and continuos from the start to the end, and the writing is never too hard, so that any gap will easily show itself during the reading.<br />Have a look at the table of contents. It starts from digital logic basics and it ends at the Interrupts chapter (this means, almost, operating systems). The distance seems to be prohibitive, but the path traced by prof. Ward and Halstead is remarkably solid and meaningful. Once basic logic circuits blocks are covered, it leads to computation issues (from FSM to Turing Machines), passing from performance considerations (e.g. pipelining) and memory hierarchies (cache memory is extensively covered).<BR>Two chapters are devoted to milestone architectures: the S machine and the G machine. Such a thorough coverage on these two machines is something I've not found in other books.<BR>The chapters on Processes, Processor Multiplexing, Processes Synchronization and Interrupts are good and at the level of an OS course. The astonishing thing is that the background to face these issues is well built before (again, recall that the book starts from basic Logic Levels !).<br />This book has been a very worthy read. My course used materials from different books, internet resources and my instructor's knowledge. The instructor itself suggested us to give the book a complete read when we had time (we didn't cover all the topics of the book) because we would have really learned important things. I've not done it completely, but the more I do it, the more I agree.	2001-10-29
US	52125825	R3RTSC0DW2KACQ	0130319996	255500080	Operating Systems: Internals and Design Principles (4th Edition)	Books	5	10	11	N	N	Unconvential, yet very useful	I liked this book's organization. I have also Tanenbaum's and Silberschatz's; what I concluded it's that this book, even if sometime appeared to be a bit ... compacted on some &quot;traditional&quot; issues (if I can judge them this way on the basis of the other two books, but processes' statuses are covered here better than anywhere else), it has given space to some other very interesting ones, starting from Security, and going on with SMP topics.<br />I particularly enjoyed the view it adopted even on common topics. E.g. the emphasis it gave to subtleties like distinguish the nature of the four requirements for deadlocks, the classification of various policies and mechanism (in a astonishingly efficient way) for topics like scheduling, paged memory issues or the importance of interrupts as The tool for modern techniques and achievements.<br />And ... the chapter on security has been a lifesave for me on the last days of the course.<br />Keep this book near to Tanenbaum's second edition of &quot;Modern Operatin System&quot; if you can, and you'll have plenty of good material for a typical OS course.	2001-10-29
US	52125825	R36FQBRJXJCMNN	0137691912	957136827	Digital Design: Principles and Practices, Third Edition	Books	5	12	12	N	N	Complete, funny and useful	This is about the best book on Digital Design I've had in my hands. It was strongly recommended by our professor, and the whole class totally agreed after a few weeks.<br />It is complete since I had a class that was half a Digital Design course. I found every topics treated in a complete and detailed way.<br />It is useful, because in my opinion the included Xilinx Software alone worths the whole price. It is a powerful tool that lets you put in practice what you've learned from the book.<br />And it is as funny as a book on this subject can be ... one can learn it from the first pages. This helps taking the book in your hands even when studying is not exactly the funniest thing you could do.<br />The overall quality, hence, remains 5 stars from me even if ... printing errors have been sometime very annoying. I think the Updated Edition should be a good remedy to this drawback.	2001-01-11
US	52125825	RQQYAJD7MTLLJ	0471364142	660825100	Operating System Concepts, 5th Edition	Books	5	7	8	N	N	Look at the title	As the title says this book is about concepts on Operating Systems. From this point of view the book is written very carefully. At a first contact I felt it was too high level as said by another reviewer before. But the title says Concepts, actually. And concepts are explained very well, in a straightforward way. If you are concerned more with implementation issue, then you should look at Tanenbaum or the other book by Silberschatz that deals with implementation.	2000-12-09
US	52125825	R2U7HXTOJMIM7J	0451521943	259828480	Ivanhoe (Signet classics)	Books	5	0	0	N	N	Excellent picture of English Middle-Age	... Sir Walter Scott has an undoubted descriptive power. The book perfectly succeeds into re-creating historic images and sensations. Everything you need to enter the romance with all its characters and sceneries is just a little bit of fantasy: Sir W. Scott will do all the rest. An invaluable work.	1999-10-15
